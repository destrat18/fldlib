/**************************************************************************/
/*                                                                        */
/*  Copyright (C) 2011-2025                                               */
/*    CEA (Commissariat a l'Energie Atomique et aux Energies              */
/*         Alternatives)                                                  */
/*                                                                        */
/*  you can redistribute it and/or modify it under the terms of the GNU   */
/*  Lesser General Public License as published by the Free Software       */
/*  Foundation, version 2.1.                                              */
/*                                                                        */
/*  It is distributed in the hope that it will be useful,                 */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
/*  GNU Lesser General Public License for more details.                   */
/*                                                                        */
/*  See the GNU Lesser General Public License version 2.1                 */
/*  for more details (enclosed in the file LICENSE).                      */
/*                                                                        */
/**************************************************************************/

/////////////////////////////////
//
// Library   : NumericalDomains
// Unit      : Affine relationships
// File      : FloatAffineOption.template
// Description :
//   Implementation of an optional class of affine relations with conditional
//     relationships between discrete int and continuous float domains.
//

#pragma once

#include "FloatAffineOption.h"
#include <iostream>
#include "NumericalAnalysis/FloatAffineExecutionPath.template"

namespace NumericalDomains {

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::conditionalAssigns(
      std::vector<std::pair<int, bool>>::const_iterator pathBegin,
      std::vector<std::pair<int, bool>>::const_iterator pathEnd, const ValueType& sourceValue) {
   if (pathBegin == pathEnd) {
      uThenValue = uElseValue = sourceValue;
      spibThenBranch.reset(); spibElseBranch.reset();
      return;
   }
   if (pathBegin->first < uMergeBranchIndex) {
      TValueWithBranches<ValueType> copy(pathBegin->first,
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)),
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)));
      if (pathBegin->second)
         copy.spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, sourceValue);
      else
         copy.spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, sourceValue);
      operator=(copy);
      return;
   }
   if (pathBegin->first == uMergeBranchIndex) {
      if (pathBegin->second) {
         if (spibThenBranch.use_count() > 1)
            spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
         spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, sourceValue);
      }
      else {
         if (spibElseBranch.use_count() > 1)
            spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
         spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, sourceValue);
      };
      return;
   }
   // pathBegin->first > uMergeBranchIndex
   if (spibThenBranch.use_count() > 1)
      spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
   spibThenBranch->conditionalAssigns(pathBegin, pathEnd, sourceValue);
   if (spibElseBranch.use_count() > 1)
      spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
   spibElseBranch->conditionalAssigns(pathBegin, pathEnd, sourceValue);
}

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::conditionalAssigns(
      std::vector<std::pair<int, bool>>::const_iterator pathBegin,
      std::vector<std::pair<int, bool>>::const_iterator pathEnd, const thisType& source) {
   if (pathBegin == pathEnd) {
      operator=(source);
      return;
   }
   int conditionBranchIndex = pathBegin->first;
   if ((source.uMergeBranchIndex < uMergeBranchIndex)
         && source.uMergeBranchIndex < conditionBranchIndex) {
      TValueWithBranches<ValueType> copy(source.uMergeBranchIndex,
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)),
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)));
      if (source.spibThenBranch.get())
         copy.spibThenBranch->conditionalAssigns(pathBegin, pathEnd, *source.spibThenBranch);
      else
         copy.spibThenBranch->conditionalAssigns(pathBegin, pathEnd, source.uThenValue);
      if (source.spibElseBranch.get())
         copy.spibElseBranch->conditionalAssigns(pathBegin, pathEnd, *source.spibElseBranch);
      else
         copy.spibElseBranch->conditionalAssigns(pathBegin, pathEnd, source.uElseValue);
      operator=(copy);
      return;
   }
   if ((conditionBranchIndex < uMergeBranchIndex)
         && (conditionBranchIndex < source.uMergeBranchIndex)) {
      TValueWithBranches<ValueType> copy(pathBegin->first,
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)),
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)));
      if (pathBegin->second)
         copy.spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, source);
      else
         copy.spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, source);
      operator=(copy);
      return;
   }
   if ((uMergeBranchIndex < source.uMergeBranchIndex)
         && (uMergeBranchIndex < conditionBranchIndex)) {
      if (spibThenBranch.use_count() > 1)
         spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
      spibThenBranch->conditionalAssigns(pathBegin, pathEnd, source);
      if (spibElseBranch.use_count() > 1)
         spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
      spibElseBranch->conditionalAssigns(pathBegin, pathEnd, source);
      return;
   }
   if (source.uMergeBranchIndex == uMergeBranchIndex) {
      // source.uMergeBranchIndex <= conditionBranchIndex
      if (source.uMergeBranchIndex == conditionBranchIndex) {
         if (pathBegin->second) {
            if (spibThenBranch.use_count() > 1)
               spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
            if (source.spibThenBranch.get())
               spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, *source.spibThenBranch);
            else
               spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, source.uThenValue);
         }
         else {
            if (spibElseBranch.use_count() > 1)
               spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
            if (source.spibElseBranch.get())
               spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, *source.spibElseBranch);
            else
               spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, source.uElseValue);
         }
         return;
      }
      // uMergeBranchIndex == source.uMergeBranchIndex < conditionBranchIndex
      if (spibThenBranch.use_count() > 1)
         spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
      if (source.spibThenBranch.get())
         spibThenBranch->conditionalAssigns(pathBegin, pathEnd, *source.spibThenBranch);
      else
         spibThenBranch->conditionalAssigns(pathBegin, pathEnd, source.uThenValue);
      if (spibElseBranch.use_count() > 1)
         spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
      if (source.spibElseBranch.get())
         spibElseBranch->conditionalAssigns(pathBegin, pathEnd, *source.spibElseBranch);
      else
         spibElseBranch->conditionalAssigns(pathBegin, pathEnd, source.uElseValue);
   }
   if (source.uMergeBranchIndex == conditionBranchIndex) {
      // source.uMergeBranchIndex == conditionBranchIndex < uMergeBranchIndex
      TValueWithBranches<ValueType> copy(source.uMergeBranchIndex,
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)),
            uThenValue, std::shared_ptr<TValueWithBranches<ValueType>>(new TValueWithBranches<ValueType>(*this)));
      if (pathBegin->second) {
         if (source.spibThenBranch.get())
            copy.spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, *source.spibThenBranch);
         else
            copy.spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, source.uThenValue);
      }
      else {
         if (source.spibElseBranch.get())
            copy.spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, *source.spibElseBranch);
         else
            copy.spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, source.uElseValue);
      }
      operator=(copy);
      return;
   }
   AssumeCondition(uMergeBranchIndex == conditionBranchIndex
         && conditionBranchIndex < source.uMergeBranchIndex)
   if (pathBegin->second) {
      if (spibThenBranch.use_count() > 1)
         spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
      spibThenBranch->conditionalAssigns(pathBegin+1, pathEnd, source);
   }
   else {
      if (spibElseBranch.use_count() > 1)
         spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
      spibElseBranch->conditionalAssigns(pathBegin+1, pathEnd, source);
   }
}

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::applyAssign(
      std::function<void (ValueType&)> function) {
   function(uThenValue);
   if (spibThenBranch.get()) {
      if (spibThenBranch.use_count() > 1)
         spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
      spibThenBranch->applyAssign(function);
   }
   function(uElseValue);
   if (spibElseBranch.get()) {
      if (spibElseBranch.use_count() > 1)
         spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
      spibElseBranch->applyAssign(function);
   }
}

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::apply(
      const std::function<void (const ValueType&)>& function) const {
   if (spibThenBranch.get())
      spibThenBranch->apply(function);
   else
      function(uThenValue);
   if (spibElseBranch.get())
      spibElseBranch->apply(function);
   else
      function(uElseValue);
}

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::applyBranchAssign(int mergeBranchIndex,
      ValueType& thisValue, std::shared_ptr<TValueWithBranches<ValueType>>& thisBranch,
      const std::function<void (ValueType&,
         std::shared_ptr<TValueWithBranches<ValueType>>&)>& function) {
   if (!thisBranch.get() || (mergeBranchIndex < thisBranch->uMergeBranchIndex))
      function(thisValue, thisBranch);
   else {
      applyBranchAssign(mergeBranchIndex, thisBranch->uThenValue,
            thisBranch->spibThenBranch, function);
      applyBranchAssign(mergeBranchIndex, thisBranch->uElseValue,
            thisBranch->spibElseBranch, function);
   }
}

template<typename ValueType>
inline void
FldlibBase::TValueWithBranches<ValueType>::applyBranchAssign(int mergeBranchIndex,
      ValueType& thisValue, std::shared_ptr<TValueWithBranches<ValueType>>& thisBranch,
      ValueType& sourceValue, std::shared_ptr<TValueWithBranches<ValueType>>& sourceBranch,
      const std::function<void (ValueType&,
         std::shared_ptr<TValueWithBranches<ValueType>>&, ValueType&,
         std::shared_ptr<TValueWithBranches<ValueType>>&)>& function) {
   if ((!thisBranch.get() || (mergeBranchIndex < thisBranch->uMergeBranchIndex))
         && (!sourceBranch.get() || (mergeBranchIndex < sourceBranch->uMergeBranchIndex))) {
      function(thisValue, thisBranch, sourceValue, sourceBranch);
      return;
   }
   if (!sourceBranch.get() || (thisBranch.get()
         && thisBranch->uMergeBranchIndex < sourceBranch->uMergeBranchIndex)) {
      applyBranchAssign(mergeBranchIndex, thisBranch->uThenValue, thisBranch->spibThenBranch,
            sourceValue, sourceBranch, function);
      applyBranchAssign(mergeBranchIndex, thisBranch->uElseValue, thisBranch->spibElseBranch,
            sourceValue, sourceBranch, function);
      return;
   }
   if (!thisBranch.get() || 
         sourceBranch->uMergeBranchIndex < thisBranch->uMergeBranchIndex) {
      applyBranchAssign(mergeBranchIndex, thisValue, thisBranch,
            sourceBranch->uThenValue, sourceBranch->spibThenBranch, function);
      applyBranchAssign(mergeBranchIndex, thisValue, thisBranch,
            sourceBranch->uElseValue, sourceBranch->spibElseBranch, function);
      return;
   }
   AssumeCondition(thisBranch->uMergeBranchIndex == sourceBranch->uMergeBranchIndex)
   applyBranchAssign(mergeBranchIndex, thisBranch->uThenValue, thisBranch->spibThenBranch,
         sourceBranch->uThenValue, sourceBranch->spibThenBranch, function);
   applyBranchAssign(mergeBranchIndex, thisBranch->uElseValue, thisBranch->spibElseBranch,
         sourceBranch->uElseValue, sourceBranch->spibElseBranch, function);
}

template<typename ValueType>
inline typename FldlibBase::TValueWithBranches<ValueType>::BranchConstraint
FldlibBase::TValueWithBranches<ValueType>::mergeBranchConstraint(
      BranchConstraint& branchConstraintThen,
      BranchConstraint& branchConstraintElse) const {
   if ((branchConstraintThen.constraintResult == BranchConstraint::CRRemove
         || branchConstraintThen.constraintResult == BranchConstraint::CRStable)
         && branchConstraintElse.constraintResult == branchConstraintThen.constraintResult)
      return BranchConstraint(branchConstraintThen.constraintResult);
   if (branchConstraintThen.constraintResult == BranchConstraint::CRRemove) {
      // branchConstraintElse.constraintResult != CRRemove
      if ((branchConstraintElse.constraintResult == BranchConstraint::CRSimplifyWithConstant)
            || (branchConstraintElse.constraintResult == BranchConstraint::CRStable
                  && !spibElseBranch.get()))
         return BranchConstraint(branchConstraintElse.constraintResult == BranchConstraint::CRSimplifyWithConstant
               ?  branchConstraintElse.constantResult : uElseValue);
      // branchConstraintElse.constraintResult == CRStable, CRSimplifyWithBranch
      return BranchConstraint((branchConstraintElse.constraintResult == BranchConstraint::CRStable)
            ? spibElseBranch : branchConstraintElse.simplifiedResult);
   }
   if (branchConstraintElse.constraintResult == BranchConstraint::CRRemove) {
      // branchConstraintThen.constraintResult != CRRemove
      if ((branchConstraintThen.constraintResult == BranchConstraint::CRSimplifyWithConstant)
            || (branchConstraintThen.constraintResult == BranchConstraint::CRStable
                  && !spibThenBranch.get()))
         return BranchConstraint(branchConstraintThen.constraintResult == BranchConstraint::CRSimplifyWithConstant
               ?  branchConstraintThen.constantResult : uThenValue);
      // branchConstraintThen.constraintResult == CRStable, CRSimplifyWithBranch
      return BranchConstraint((branchConstraintThen.constraintResult == BranchConstraint::CRStable)
            ? spibThenBranch : branchConstraintThen.simplifiedResult);
   }
   if (branchConstraintThen.constraintResult == BranchConstraint::CRStable) { 
      // branchConstraintElse.constraintResult == CRSimplifyWithConstant, CRSimplifyWithBranch
      if (branchConstraintElse.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         if (!spibThenBranch.get() && branchConstraintElse.constantResult == uThenValue)
            return branchConstraintElse;
         std::shared_ptr<thisType> result(new thisType(*this));
         result->spibElseBranch.reset();
         result->uElseValue = branchConstraintElse.constantResult;
         return BranchConstraint(std::move(result));
      }
      std::shared_ptr<thisType> result(new thisType(*this));
      result->spibElseBranch = branchConstraintElse.simplifiedResult;
      return BranchConstraint(std::move(result));
   }
   if (branchConstraintElse.constraintResult == BranchConstraint::CRStable) { 
      // branchConstraintThen.constraintResult == CRSimplifyWithConstant, CRSimplifyWithBranch
      if (branchConstraintThen.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         if (!spibElseBranch.get() && branchConstraintThen.constantResult == uElseValue)
            return branchConstraintThen;
         std::shared_ptr<thisType> result(new thisType(*this));
         result->spibThenBranch.reset();
         result->uThenValue = branchConstraintThen.constantResult;
         return BranchConstraint(std::move(result));
      }
      std::shared_ptr<thisType> result(new thisType(*this));
      result->spibThenBranch = branchConstraintThen.simplifiedResult;
      return BranchConstraint(std::move(result));
   }
   // branchConstraintThen.constraintResult == CRSimplifyWithConstant, CRSimplifyWithBranch
   // branchConstraintElse.constraintResult == CRSimplifyWithConstant, CRSimplifyWithBranch
   if ((branchConstraintThen.constraintResult == BranchConstraint::CRSimplifyWithConstant)
         && (branchConstraintElse.constraintResult == BranchConstraint::CRSimplifyWithConstant)
         && branchConstraintThen.constantResult == branchConstraintElse.constantResult)
      return branchConstraintThen;
   std::shared_ptr<thisType> result(new thisType(*this));
   result->spibThenBranch = branchConstraintThen.simplifiedResult;
   result->uThenValue = branchConstraintThen.constantResult;
   result->spibElseBranch = branchConstraintElse.simplifiedResult;
   result->uElseValue = branchConstraintElse.constantResult;
   return BranchConstraint(std::move(result));
}

template<typename ValueType>
inline typename FldlibBase::TValueWithBranches<ValueType>::BranchConstraint
FldlibBase::TValueWithBranches<ValueType>::constraint(
      const std::function<bool (const ValueType&)>& function) const {
   BranchConstraint branchConstraintThen, branchConstraintElse;
   if (spibThenBranch.get())
      branchConstraintThen = spibThenBranch->constraint(function);
   else if (!function(uThenValue))
      branchConstraintThen.constraintResult = BranchConstraint::CRRemove;
   if (spibElseBranch.get())
      branchConstraintElse = spibElseBranch->constraint(function);
   else if (!function(uElseValue))
      branchConstraintElse.constraintResult = BranchConstraint::CRRemove;
   return mergeBranchConstraint(branchConstraintThen, branchConstraintElse);
}

template<typename ValueType>
template <typename T>
inline void
FldlibBase::TValueWithBranches<ValueType>::applyAssign(const FldlibBase::TValueWithBranches<T>& source,
      std::function<void (ValueType&, const T&)> function) {
   if (uMergeBranchIndex == source.uMergeBranchIndex) {
      function(uThenValue, source.uThenValue);
      if (spibThenBranch.get()) {
         if (spibThenBranch.use_count() > 1)
            spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
         if (source.spibThenBranch.get())
            spibThenBranch->applyAssign(*source.spibThenBranch, function);
         else
            spibThenBranch->applyAssign([&source, &function](ValueType& arg)
               {  function(arg, source.uThenValue); });
      }
      else if (source.spibThenBranch.get()) {
         spibThenBranch.reset(new TValueWithBranches(*source.spibThenBranch));
         spibThenBranch->applyAssign([this, &function](ValueType& arg)
            {  ValueType originalSource = arg;
               arg = uThenValue;
               function(arg, originalSource);
            });
      }
      function(uElseValue, source.uElseValue);
      if (spibElseBranch.get()) {
         if (spibElseBranch.use_count() > 1)
            spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
         if (source.spibElseBranch.get())
            spibElseBranch->applyAssign(*source.spibElseBranch, function);
         else
            spibElseBranch->applyAssign([&source, &function](ValueType& arg)
               {  function(arg, source.uElseValue); });
      }
      else if (source.spibElseBranch.get()) {
         spibElseBranch.reset(new TValueWithBranches(*source.spibElseBranch));
         spibElseBranch->applyAssign([this, &function](ValueType& arg)
            {  ValueType originalSource = arg;
               arg = uElseValue;
               function(arg, originalSource);
            });
      }
   }
   else if (uMergeBranchIndex < source.uMergeBranchIndex) {
      function(uThenValue, source.uThenValue);
      if (spibThenBranch.get()) {
         if (spibThenBranch.use_count() > 1)
            spibThenBranch.reset(new TValueWithBranches(*spibThenBranch));
         spibThenBranch->applyAssign(source, function);
      }
      else if (source.spibThenBranch.get()) {
         spibThenBranch.reset(new TValueWithBranches(source));
         spibThenBranch->applyAssign([this, &function](ValueType& arg)
            {  ValueType originalSource = arg;
               arg = uThenValue;
               function(arg, originalSource);
            });
      }
      function(uElseValue, source.uElseValue);
      if (spibElseBranch.get()) {
         if (spibElseBranch.use_count() > 1)
            spibElseBranch.reset(new TValueWithBranches(*spibElseBranch));
         spibElseBranch->applyAssign(source, function);
      }
      else if (source.spibElseBranch.get()) {
         spibElseBranch.reset(new TValueWithBranches(source));
         spibElseBranch->applyAssign([this, &function](ValueType& arg)
            {  ValueType originalSource = arg;
               arg = uElseValue;
               function(arg, originalSource);
            });
      }
   }
   else { // uMergeBranchIndex > source.uMergeBranchIndex
      int thisMergeBranchIndex = uMergeBranchIndex;
      ValueType thisThenValue = uThenValue;
      std::shared_ptr<thisType> thisThenBranch = spibThenBranch;
      ValueType thisElseValue = uElseValue;
      std::shared_ptr<thisType> thisElseBranch = spibElseBranch;
      function(uThenValue, source.uThenValue);
      function(uElseValue, source.uElseValue);

      uMergeBranchIndex = source.uMergeBranchIndex;
      spibThenBranch.reset(new TValueWithBranches(thisMergeBranchIndex, thisThenValue,
         thisThenBranch, thisElseValue, thisElseBranch));
      if (source.spibThenBranch.get())
         spibThenBranch->applyAssign(*source.spibThenBranch, function);
      spibElseBranch.reset(new TValueWithBranches(thisMergeBranchIndex, thisThenValue,
         thisThenBranch, thisElseValue, thisElseBranch));
      thisThenBranch.reset();
      thisElseBranch.reset();
      if (source.spibElseBranch.get())
         spibElseBranch->applyAssign(*source.spibElseBranch, function);
   }
}

template<typename ValueType>
template <typename T>
inline void
FldlibBase::TValueWithBranches<ValueType>::apply(const TValueWithBranches<T>& source,
      const std::function<void (const ValueType&, const T&)>& function) const {
   if (uMergeBranchIndex == source.uMergeBranchIndex) {
      if (!spibThenBranch.get() && !source.spibThenBranch.get())
         function(uThenValue, source.uThenValue);
      else if (!source.spibThenBranch.get())
         spibThenBranch->apply([&source, &function](const ValueType& arg)
               {  function(arg, source.uThenValue); });
      else if (!spibThenBranch.get())
         source.spibThenBranch->apply([this, &function](const ValueType& arg)
               {  function(uThenValue, arg); });
      else
         spibThenBranch->apply(*source.spibThenBranch, function);
      if (!spibElseBranch.get() && !source.spibElseBranch.get())
         function(uElseValue, source.uElseValue);
      else if (!source.spibElseBranch.get())
         spibElseBranch->apply([&source, &function](const ValueType& arg)
               {  function(arg, source.uElseValue); });
      else if (!spibElseBranch.get())
         source.spibElseBranch->apply([this, &function](const ValueType& arg)
               {  function(uElseValue, arg); });
      else
         spibElseBranch->apply(*source.spibElseBranch, function);
   }
   else if (uMergeBranchIndex < source.uMergeBranchIndex) {
      if (!spibThenBranch.get())
         source.apply([this, &function](const T& sourceValue)
            {  function(uThenValue, sourceValue); });
      else
         spibThenBranch->apply(source, function);
      if (!spibElseBranch.get())
         source.apply([this, &function](const T& sourceValue)
            {  function(uElseValue, sourceValue); });
      else
         spibElseBranch->apply(source, function);
   }
   else { // uMergeBranchIndex > source.uMergeBranchIndex
      if (!source.spibThenBranch.get())
         apply([&source, &function](const T& thisValue)
            {  function(thisValue, source.uThenValue); });
      else
         apply(*source.spibThenBranch, function);
      if (!source.spibElseBranch.get())
         apply([&source, &function](const T& thisValue)
            {  function(thisValue, source.uElseValue); });
      else
         apply(*source.spibElseBranch, function);
   }
}

template<typename ValueType>
template <typename T>
inline std::pair<typename FldlibBase::TValueWithBranches<ValueType>::BranchConstraint,
          typename FldlibBase::TValueWithBranches<T>::BranchConstraint>
FldlibBase::TValueWithBranches<ValueType>::constraint(const TValueWithBranches<T>& source,
      const std::function<bool (const ValueType&, const T&)>& function) {
   if (uMergeBranchIndex == source.uMergeBranchIndex) {
      BranchConstraint branchConstraintThisThen, branchConstraintThisElse;
      typedef typename TValueWithBranches<T>::BranchConstraint SourceBranchConstraint;
      SourceBranchConstraint branchConstraintSourceThen, branchConstraintSourceElse;
      if (!spibThenBranch.get() && !source.spibThenBranch.get()) {
         if (!function(uThenValue, source.uThenValue)) {
            branchConstraintThisThen.constraintResult = BranchConstraint::CRRemove;
            branchConstraintSourceThen.constraintResult = SourceBranchConstraint::CRRemove;
         }
      }
      else if (!source.spibThenBranch.get()) {
         branchConstraintThisThen = spibThenBranch->constraint(
            [&source, &function](const ValueType& arg)
            {  return function(arg, source.uThenValue); });
         if (branchConstraintThisThen.constraintResult == BranchConstraint::CRRemove)
            branchConstraintSourceThen.constraintResult = SourceBranchConstraint::CRRemove;
      }
      else if (!spibThenBranch.get()) {
         branchConstraintSourceThen = source.spibThenBranch->constraint(
            [this, &function](const ValueType& sourceArg)
            {  return function(uThenValue, sourceArg); });
         if (branchConstraintSourceThen.constraintResult == SourceBranchConstraint::CRRemove)
            branchConstraintThisThen.constraintResult = BranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisThen, branchConstraintSourceThen)
            = spibThenBranch->constraint(*source.spibThenBranch, function);
      if (!spibElseBranch.get() && !source.spibElseBranch.get()) {
         if (!function(uElseValue, source.uElseValue)) {
            branchConstraintThisElse.constraintResult = BranchConstraint::CRRemove;
            branchConstraintSourceElse.constraintResult = SourceBranchConstraint::CRRemove;
         }
      }
      else if (!source.spibElseBranch.get()) {
         branchConstraintThisElse = spibElseBranch->constraint(
            [&source, &function](const ValueType& arg)
            {  return function(arg, source.uElseValue); });
         if (branchConstraintThisElse.constraintResult == BranchConstraint::CRRemove)
            branchConstraintSourceElse.constraintResult = SourceBranchConstraint::CRRemove;
      }
      else if (!spibElseBranch.get()) {
         branchConstraintSourceElse = source.spibElseBranch->constraint(
            [this, &function](const ValueType& sourceArg)
            {  return function(uElseValue, sourceArg); });
         if (branchConstraintSourceElse.constraintResult == SourceBranchConstraint::CRRemove)
            branchConstraintThisElse.constraintResult = BranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisElse, branchConstraintSourceElse)
            = spibElseBranch->constraint(*source.spibElseBranch, function);
      return std::make_pair(mergeBranchConstraint(branchConstraintThisThen, branchConstraintThisElse),
            source.mergeBranchConstraint(branchConstraintSourceThen, branchConstraintSourceElse));
   }
   else if (uMergeBranchIndex < source.uMergeBranchIndex) {
      BranchConstraint branchConstraintThisThen, branchConstraintThisElse;
      typedef typename TValueWithBranches<T>::BranchConstraint SourceBranchConstraint;
      SourceBranchConstraint branchConstraintSourceWithThisThen, branchConstraintSourceWithThisElse;
      if (!spibThenBranch.get()) {
         branchConstraintSourceWithThisThen = source.constraint([this, &function](const T& sourceArg)
            {  return function(uThenValue, sourceArg); });
         if (branchConstraintSourceWithThisThen.constraintResult == SourceBranchConstraint::CRRemove)
            branchConstraintThisThen.constraintResult = BranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisThen, branchConstraintSourceWithThisThen)
            = spibThenBranch->constraint(source, function);
      if (!spibElseBranch.get()) {
         branchConstraintSourceWithThisElse = source.constraint([this, &function](const T& sourceArg)
            {  return function(uElseValue, sourceArg); });
         if (branchConstraintSourceWithThisElse.constraintResult == SourceBranchConstraint::CRRemove)
            branchConstraintThisElse.constraintResult = BranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisElse, branchConstraintSourceWithThisElse)
            = spibElseBranch->constraint(source, function);
      branchConstraintSourceWithThisThen.mergeWith(branchConstraintSourceWithThisElse,
            uMergeBranchIndex);
      return std::make_pair(mergeBranchConstraint(branchConstraintThisThen, branchConstraintThisElse),
            branchConstraintSourceWithThisThen);
   }
   else { // uMergeBranchIndex > source.uMergeBranchIndex
      BranchConstraint branchConstraintThisWithSourceThen, branchConstraintThisWithSourceElse;
      typedef typename TValueWithBranches<T>::BranchConstraint SourceBranchConstraint;
      SourceBranchConstraint branchConstraintSourceThen, branchConstraintSourceElse;
      if (!source.spibThenBranch.get()) {
         branchConstraintThisWithSourceThen = constraint([&source, &function](const ValueType& thisArg)
            {  return function(thisArg, source.uThenValue); });
         if (branchConstraintThisWithSourceThen.constraintResult == BranchConstraint::CRRemove)
            branchConstraintSourceThen.constraintResult = SourceBranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisWithSourceThen, branchConstraintSourceThen)
            = constraint(*source.spibThenBranch, function);
      if (!source.spibElseBranch.get()) {
         branchConstraintThisWithSourceElse = constraint([&source, &function](const ValueType& thisArg)
            {  return function(thisArg, source.uElseValue); });
         if (branchConstraintThisWithSourceElse.constraintResult == BranchConstraint::CRRemove)
            branchConstraintSourceElse.constraintResult = SourceBranchConstraint::CRRemove;
      }
      else
         std::tie(branchConstraintThisWithSourceElse, branchConstraintSourceElse)
            = constraint(*source.spibElseBranch, function);
      branchConstraintThisWithSourceThen.mergeWith(branchConstraintThisWithSourceElse,
            source.uMergeBranchIndex);
      return std::make_pair(branchConstraintThisWithSourceThen,
            source.mergeBranchConstraint(branchConstraintSourceThen, branchConstraintSourceElse));
   }
}

// implementation of the template class TFldlibIntegerBranchOption

template <typename IntegerType> requires std::integral<IntegerType>
inline bool
TFldlibIntegerBranchOption<IntegerType>::BranchCursor::setToFirst() {
   AssumeCondition(pibSupport)
   path.clear();
   vibPathParent.clear();
   vibPathParent.push_back(std::make_pair(&pibSupport->value, &pibSupport->conditionalValue));
   while (vibPathParent.back().second->get()) {
      path.push_back(std::make_pair((*vibPathParent.back().second)->getMergeBranchIndex(), true));
      vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSThenValue(),
         &(*vibPathParent.back().second)->getSThenBranch()));
   }
   return true;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline bool
TFldlibIntegerBranchOption<IntegerType>::BranchCursor::setToNext() {
   AssumeCondition(pibSupport)
   if (vibPathParent.empty())
      return setToFirst();
   if (vibPathParent.size() == 1) { // root
      vibPathParent.clear();
      return false;
   }
   while (!path.empty() && path.back().second == false) {
      vibPathParent.pop_back();
      path.pop_back();
      AssumeCondition(!vibPathParent.empty())
   }
   if (!path.empty() && path.back().second == true) {
      path.back().second = false;
      vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSElseValue(),
         &(*vibPathParent.back().second)->getSElseBranch()));
      while (vibPathParent.back().second->get()) {
         path.push_back(std::make_pair((*vibPathParent.back().second)->getMergeBranchIndex(), true));
         vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSThenValue(),
            &(*vibPathParent.back().second)->getSThenBranch()));
      }
      return true;
   }
   AssumeCondition(path.empty() && vibPathParent.size() == 1)
   return true;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline void
TFldlibIntegerBranchOption<IntegerType>::conditionalAssigns(
      const std::vector<std::pair<int, bool>>& path, const thisType& source) {
   if (path.empty()) {
      operator=(source);
      return;
   }
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      if (value == source.value)
         return;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(path.begin()->first,
         value, std::shared_ptr<TIntegerWithBranches<IntegerType>>(),
         value, std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.value);
      return;
   }
   if (!conditionalValue.get())
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(path.begin()->first,
         value, std::shared_ptr<TIntegerWithBranches<IntegerType>>(),
         value, std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
   if (!source.conditionalValue.get())
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.value);
   else
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.cconditionalValue());
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+=(T source) -> thisType&
      requires std::floating_point<T> || std::integral<T> {
   value += source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](IntegerType& arg) { arg += source; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+=(const thisType& source) -> thisType& {
   IntegerType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  // IntegerType sourceCopy = sourceValue;
            // sourceValue = thisValue;
            // sourceValue += sourceCopy;
            sourceValue += thisValue;
         });
      
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+=(thisType&& source) -> thisType& {
   IntegerType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(conditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue += thisValue; });
      
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+=(const TFldlibIntegerBranchOption<T>& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+=(TFldlibIntegerBranchOption<T>&& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator+(T second) const
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(value + second)> result(value);
   typedef TIntegerWithBranches<decltype(value + second)> IntegerBranch;
   result.value += second;
   if (conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(value + second)& resultValue) { resultValue += second; });
   }
   return result;
}

// {  TFldlibIntegerBranchOption<decltype(first.value + second)> result(first.value + second);
//    if (!first.conditionalValue.get())
//       return result;
//    typedef TIntegerWithBranches<decltype(first.value + second)> IntegerBranch;
//    std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
//    result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue().getMergeBranchIndex(),
//          second, thenBranch, second, elseBranch));
//    result.cconditionalValue().applyAssign(first, 
//          [](decltype(first.value + second)& secondValue, const IntegerType& firstValue)
//       { secondValue += firstValue; });
//    return result;
// }

template <typename IntegerType, typename T>
inline auto
operator+(TFldlibIntegerBranchOption<IntegerType>&& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value + second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value + second)> IntegerBranch;
   result.value += second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue += second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(T first, const TFldlibIntegerBranchOption<IntegerType>& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) + IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first + second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first + second.value)> IntegerBranch;
   result.value += second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(T first, TFldlibIntegerBranchOption<IntegerType>&& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) + IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first + second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first + second.value)> IntegerBranch;
   result.value += second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + T(0))> requires std::integral<T> {
   if (std::is_same<decltype(first.value + second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value += second.value;
      if (second.conditionalValue.get()) {
         std::function<void (IntegerType&, const T&)> fun =  []
            (IntegerType& resultValue, const T& secondValue)
               {  resultValue += secondValue; };
         result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
      }
      else if (result.conditionalValue.get()) {
         result.cconditionalValue().applyAssign([second]
            (IntegerType& resultValue) { resultValue += second.value; });
      }
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value + second.value)> IntegerBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get()) {
         std::function<void (IntegerType&, const T&)> fun = []
            (decltype(first.value + second.value)& resultValue, const T& secondValue)
               {  resultValue += secondValue; };
         result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
      }
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second.value)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      std::function<void (IntegerType&, const T&)> fun = []
         (decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; };
      result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + T(0))> requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value + second)> IntegerBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + T(0))> requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value + second)> IntegerBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator+(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) + T(0))> requires std::integral<T> {
   if (std::is_same<decltype(first.value + second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value += second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value + second)> IntegerBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename IntegerType>
inline auto
operator-(const TFldlibIntegerBranchOption<IntegerType>& first) -> TFldlibIntegerBranchOption<IntegerType> {
   TFldlibIntegerBranchOption<IntegerType> result(first);
   result.value = -result.value;
   if (result.conditionalValue.get())
      result.cconditionalValue().applyAssign([]
         (IntegerType& resultValue) { resultValue = -resultValue; });
   return result;
}

template <typename IntegerType>
inline auto
operator-(TFldlibIntegerBranchOption<IntegerType>&& first) -> TFldlibIntegerBranchOption<IntegerType> {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
   result.value = -result.value;
   if (result.conditionalValue.get())
      result.cconditionalValue().applyAssign([]
         (IntegerType& resultValue) { resultValue = -resultValue; });
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator-=(T source) -> thisType&
      requires std::floating_point<T> || std::integral<T> {
   value -= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](IntegerType& arg) { arg -= source; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator-=(const thisType& source) -> thisType& {
   IntegerType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  // IntegerType sourceCopy = sourceValue;
            // sourceValue = thisValue;
            // sourceValue -= sourceCopy;
            sourceValue = thisValue - sourceValue;
         });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator-=(thisType&& source) -> thisType& {
   IntegerType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue = thisValue - sourceValue; });
      
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator-=(const TFldlibIntegerBranchOption<T>& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator-=(TFldlibIntegerBranchOption<T>&& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return *this;
}

template <typename IntegerType, typename T>
inline auto
operator-(const TFldlibIntegerBranchOption<IntegerType>& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value - second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value - second)& resultValue) { resultValue -= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(TFldlibIntegerBranchOption<IntegerType>&& first,
      T second) -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value - second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue -= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(T first, const TFldlibIntegerBranchOption<IntegerType>& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) - IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first - second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first - second.value)> IntegerBranch;
   result.value -= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(T first, TFldlibIntegerBranchOption<IntegerType>&& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) - IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first - second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first - second.value)> IntegerBranch;
   result.value -= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value - second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(first);
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value - second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - T(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator-(TFldlibIntegerBranchOption<IntegerType>&& first, TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) - T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value - second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value - second)> IntegerBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline TFldlibIntegerBranchOption<IntegerType>&
TFldlibIntegerBranchOption<IntegerType>::operator*=(T source)
      requires std::floating_point<T> || std::integral<T> {
   value *= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](IntegerType& arg) { arg *= source; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator*=(const thisType& source) -> thisType& {
   IntegerType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue *= thisValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator*=(thisType&& source) -> thisType& {
   IntegerType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue *= thisValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator*=(const TFldlibIntegerBranchOption<T>& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator*=(TFldlibIntegerBranchOption<T>&& source) -> thisType&
      requires std::integral<T> {
   IntegerType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return *this;
}

template <typename IntegerType, typename T>
inline auto
operator*(const TFldlibIntegerBranchOption<IntegerType>& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value * second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value * second)& resultValue) { resultValue *= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(TFldlibIntegerBranchOption<IntegerType>&& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * typename IntegralType<T>::base_type(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value * second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value * second)& resultValue) { resultValue *= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(T first, const TFldlibIntegerBranchOption<IntegerType>& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) * IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first * second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first * second.value)> IntegerBranch;
   result.value *= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first * second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(T first, TFldlibIntegerBranchOption<IntegerType>&& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) * IntegerType(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first * second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first * second.value)> IntegerBranch;
   result.value *= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first * second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value * second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(first);
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value * second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator*(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * T(0))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}


template <typename IntegerType, typename T>
inline auto
operator*(TFldlibIntegerBranchOption<IntegerType>&& first, TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) * T(0))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value * second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value * second)> IntegerBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator/=(T source) -> thisType&
      requires std::floating_point<T> || std::integral<T> {
   value /= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](IntegerType& arg) { arg /= source; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator/=(const thisType& source) -> thisType& {
   IntegerType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue = thisValue / sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator/=(thisType&& source) -> thisType& {
   IntegerType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue = thisValue / sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator/=(const TFldlibIntegerBranchOption<T>& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator/=(TFldlibIntegerBranchOption<T>&& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return *this;
}

template <typename IntegerType, typename T>
inline auto
operator/(const TFldlibIntegerBranchOption<IntegerType>& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / typename IntegralType<T>::base_type(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value / second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value / second)& resultValue) { resultValue /= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(TFldlibIntegerBranchOption<IntegerType>&& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / typename IntegralType<T>::base_type(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value / second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue /= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(T first, const TFldlibIntegerBranchOption<IntegerType>& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) / IntegerType(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first / second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first / second.value)> IntegerBranch;
   result.value /= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(T first, TFldlibIntegerBranchOption<IntegerType>&& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) / IntegerType(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first / second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first / second.value)> IntegerBranch;
   result.value /= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value / second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(first);
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value / second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / T(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator/(TFldlibIntegerBranchOption<IntegerType>&& first, TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) / T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value / second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value / second)> IntegerBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator%=(T source) -> thisType&
      requires std::integral<T> {
   value %= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](IntegerType& arg) { arg %= source; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator%=(const thisType& source) -> thisType& {
   IntegerType thisValue = value;
   value %= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue %= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue %= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue = thisValue % sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator%=(thisType&& source) -> thisType& {
   IntegerType thisValue = value;
   value %= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue %= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue %= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](IntegerType& sourceValue)
         {  sourceValue = thisValue % sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator%=(const TFldlibIntegerBranchOption<T>& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value %= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue %= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue %= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::operator%=(TFldlibIntegerBranchOption<T>&& source)
      -> thisType& requires std::integral<T> {
   IntegerType thisValue = value;
   value %= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](IntegerType& thisValue, const IntegerType& sourceValue) { thisValue %= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](IntegerType& thisValue) { thisValue %= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TIntegerWithBranches<IntegerType>> thenBranch, elseBranch;
      conditionalValue.reset(new TIntegerWithBranches<IntegerType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return *this;
}

template <typename IntegerType, typename T>
inline auto
operator%(const TFldlibIntegerBranchOption<IntegerType>& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % typename IntegralType<T>::base_type(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value % second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value % second)& resultValue) { resultValue %= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(TFldlibIntegerBranchOption<IntegerType>&& first, T second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % typename IntegralType<T>::base_type(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value % second)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue %= second; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(T first, const TFldlibIntegerBranchOption<IntegerType>& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) % IntegerType(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first % second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first % second.value)> IntegerBranch;
   result.value %= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(T first, TFldlibIntegerBranchOption<IntegerType>&& second)
      -> TFldlibIntegerBranchOption<decltype(typename IntegralType<T>::base_type(0) % IntegerType(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first % second.value)> result(first);
   typedef FldlibBase::TIntegerWithBranches<decltype(first % second.value)> IntegerBranch;
   result.value %= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const IntegerType& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value % second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(first);
      result.value %= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value % second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value % second.value)& thisValue, const T& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value % second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value %= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value % second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value % second.value)& thisValue, const T& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % T(1))>
      requires std::integral<T> {
   TFldlibIntegerBranchOption<decltype(first.value % second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value % second.value)& thisValue, const T& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType, typename T>
inline auto
operator%(TFldlibIntegerBranchOption<IntegerType>&& first, TFldlibIntegerBranchOption<T>&& second)
      -> TFldlibIntegerBranchOption<decltype(IntegerType(0) % T(1))>
      requires std::integral<T> {
   if (std::is_same<decltype(first.value % second.value), IntegerType>::value) {
      TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
      result.value %= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
      return result;
   };
   TFldlibIntegerBranchOption<decltype(first.value % second.value)> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<decltype(first.value % second)> IntegerBranch;
   result.value %= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value % second)& resultValue, const T& secondValue)
               {  resultValue %= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value % second)& resultValue) { resultValue %= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value % second.value)& thisValue, const T& sourceValue)
         {  thisValue %= sourceValue; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator&(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
   result.value &= second.value;
   if (second.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& secondValue)
            {  resultValue &= secondValue; };
      result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&second]
         (IntegerType& resultValue) { resultValue &= second.value; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator&(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(second));
   result.value &= first.value;
   if (first.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& firstValue)
            {  resultValue &= firstValue; };
      result.cconditionalValue().applyAssign(first.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&first]
         (IntegerType& resultValue) { resultValue &= first.value; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator&(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second) {
   TFldlibIntegerBranchOption<IntegerType> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<IntegerType> IntegerBranch;
   result.value &= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (IntegerType& resultValue, const IntegerType& secondValue)
               {  resultValue &= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (IntegerType& resultValue) { resultValue &= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue &= sourceValue; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator&(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
   result.value &= second.value;
   if (second.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& secondValue)
            {  resultValue &= secondValue; };
      result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&second]
         (IntegerType& resultValue) { resultValue &= second.value; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator|(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
   result.value |= second.value;
   if (second.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& secondValue)
            {  resultValue |= secondValue; };
      result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&second]
         (IntegerType& resultValue) { resultValue |= second.value; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator|(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(second));
   result.value |= first.value;
   if (first.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& firstValue)
            {  resultValue |= firstValue; };
      result.cconditionalValue().applyAssign(first.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&first]
         (IntegerType& resultValue) { resultValue |= first.value; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator|(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second) {
   TFldlibIntegerBranchOption<IntegerType> result(first.value);
   typedef FldlibBase::TIntegerWithBranches<IntegerType> IntegerBranch;
   result.value |= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (IntegerType& resultValue, const IntegerType& secondValue)
               {  resultValue |= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (IntegerType& resultValue) { resultValue |= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue |= sourceValue; });
   }
   return result;
}

template <typename IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
operator|(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second) {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(first));
   result.value |= second.value;
   if (second.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& secondValue)
            {  resultValue |= secondValue; };
      result.cconditionalValue().applyAssign(second.cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([&second]
         (IntegerType& resultValue) { resultValue |= second.value; });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
TFldlibIntegerBranchOption<IntegerType>::min(const TFldlibIntegerBranchOption<IntegerType>& source) const {
   TFldlibIntegerBranchOption<IntegerType> result(std::min(result.value, source.value));
   typedef FldlibBase::TIntegerWithBranches<IntegerType> IntegerBranch;
   if (conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(cconditionalValue()));
      if (source.conditionalValue.get()) {
         std::function<void (IntegerType&, const IntegerType&)> fun = []
            (IntegerType& resultValue, const IntegerType& sourceValue)
               {  resultValue = std::min(resultValue, sourceValue); };
         result.cconditionalValue().applyAssign(source.cconditionalValue(), fun);
      }
      else
         result.cconditionalValue().applyAssign([source]
            (IntegerType& resultValue) { resultValue = std::min(resultValue, source.value); });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(source.cconditionalValue().getMergeBranchIndex(),
            value, thenBranch, value, elseBranch));
      std::function<void (IntegerType&, const IntegerType&)> fun = []
         (IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue = std::min(thisValue, sourceValue); };
      result.cconditionalValue().applyAssign(source.cconditionalValue(), fun);
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
TFldlibIntegerBranchOption<IntegerType>::min(TFldlibIntegerBranchOption<IntegerType>&& source) const {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(source));
   result.value = std::min(result.value, value);
   if (conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& firstValue)
            {  resultValue = std::min(resultValue, firstValue); };
      result.cconditionalValue().applyAssign(cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([this]
         (IntegerType& resultValue) { resultValue = std::min(resultValue, value); });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>&
TFldlibIntegerBranchOption<IntegerType>::minAssign(const TFldlibIntegerBranchOption<IntegerType>& source) {
   value = std::min(value, source.value);
   if (source.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& sourceValue)
            {  resultValue = std::min(resultValue, sourceValue); };
      cconditionalValue().applyAssign(source.cconditionalValue(), fun);
   }
   else if (conditionalValue.get()) {
      cconditionalValue().applyAssign([&source]
         (IntegerType& resultValue) { resultValue = std::min(resultValue, source.value); });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
TFldlibIntegerBranchOption<IntegerType>::max(const TFldlibIntegerBranchOption<IntegerType>& source) const {
   TFldlibIntegerBranchOption<IntegerType> result(std::max(result.value, source.value));
   typedef FldlibBase::TIntegerWithBranches<IntegerType> IntegerBranch;
   if (conditionalValue.get()) {
      result.conditionalValue.reset(new IntegerBranch(cconditionalValue()));
      if (source.conditionalValue.get()) {
         std::function<void (IntegerType&, const IntegerType&)> fun = []
            (IntegerType& resultValue, const IntegerType& sourceValue)
               {  resultValue = std::max(resultValue, sourceValue); };
         result.cconditionalValue().applyAssign(source.cconditionalValue(), fun);
      }
      else
         result.cconditionalValue().applyAssign([source]
            (IntegerType& resultValue) { resultValue = std::max(resultValue, source.value); });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<IntegerBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new IntegerBranch(source.cconditionalValue().getMergeBranchIndex(),
            value, thenBranch, value, elseBranch));
      std::function<void (IntegerType&, const IntegerType&)> fun = []
         (IntegerType& thisValue, const IntegerType& sourceValue)
         {  thisValue = std::max(thisValue, sourceValue); };
      result.cconditionalValue().applyAssign(source.cconditionalValue(), fun);
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>
TFldlibIntegerBranchOption<IntegerType>::max(TFldlibIntegerBranchOption<IntegerType>&& source) const {
   TFldlibIntegerBranchOption<IntegerType> result(std::move(source));
   result.value = std::max(result.value, value);
   if (conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& firstValue)
            {  resultValue = std::max(resultValue, firstValue); };
      result.cconditionalValue().applyAssign(cconditionalValue(), fun);
   }
   else if (result.conditionalValue.get()) {
      result.cconditionalValue().applyAssign([this]
         (IntegerType& resultValue) { resultValue = std::max(resultValue, value); });
   }
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<IntegerType>&
TFldlibIntegerBranchOption<IntegerType>::maxAssign(const TFldlibIntegerBranchOption<IntegerType>& source) {
   value = std::max(value, source.value);
   if (source.conditionalValue.get()) {
      std::function<void (IntegerType&, const IntegerType&)> fun =  []
         (IntegerType& resultValue, const IntegerType& sourceValue)
            {  resultValue = std::max(resultValue, sourceValue); };
      cconditionalValue().applyAssign(source.cconditionalValue(), fun);
   }
   else if (conditionalValue.get()) {
      cconditionalValue().applyAssign([&source]
         (IntegerType& resultValue) { resultValue = std::max(resultValue, source.value); });
   }
   return *this;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T> requires std::integral<T>
inline auto
TFldlibIntegerBranchOption<IntegerType>::fullCompare(const TFldlibIntegerBranchOption<T>& source) const
      -> FullComparisonResult {
   if (!conditionalValue.get() && !source.conditionalValue.get())
      return (value < source.value) ? FCRLess : ((value > source.value) ? FCRGreater : FCREqual);
   FullComparisonResult result = FCRUndefined;
   if (!source.conditionalValue.get()) {
      cconditionalValue().apply([&result, &source](const IntegerType& val)
         {  if (val < source.value)
               result = (FullComparisonResult) (result | FCRLess);
            else if (val > source.value)
               result = (FullComparisonResult) (result | FCRGreater);
            else
               result = (FullComparisonResult) (result | FCREqual);
         });
      return result;
   }
   if (!conditionalValue.get()) {
      source.cconditionalValue().apply([&result, this](const T& sourceVal)
         {  if (value < sourceVal)
               result = (FullComparisonResult) (result | FCRLess);
            else if (value > sourceVal)
               result = (FullComparisonResult) (result | FCRGreater);
            else
               result = (FullComparisonResult) (result | FCREqual);
         });
      return result;
   }
   cconditionalValue().apply(source.cconditionalValue(),
      std::function<void (const IntegerType&, const T&)>(
      [&result](const IntegerType& thisValue, const T& sourceValue) -> void
      {  if (thisValue < sourceValue)
            result = (FullComparisonResult) (result | FCRLess);
         else if (thisValue > sourceValue)
            result = (FullComparisonResult) (result | FCRGreater);
         else
            result = (FullComparisonResult) (result | FCREqual);
      }));
   return result;
}

template <typename IntegerType> requires std::integral<IntegerType>
template<typename T>
inline bool
TFldlibIntegerBranchOption<IntegerType>::constraintCompare(TFldlibIntegerBranchOption<T>& source,
      FullComparisonResult expectedResult
      /* , MergedExecutionPath& mergedExecutionPath could remove some BranchInformation in branchDictionary*/) {
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      FullComparisonResult compareResult = (value < source.value) ? FCRLess : ((value > source.value) ? FCRGreater : FCREqual);
      return (compareResult & expectedResult);
   }
   if (!source.conditionalValue.get()) {
      typedef typename TIntegerWithBranches<IntegerType>::BranchConstraint BranchConstraint;
      BranchConstraint thisConstraint = cconditionalValue().constraint(
         [&source, expectedResult](const IntegerType& val) -> bool
         {  FullComparisonResult compareResult = (val < source.value) ? FCRLess : ((val > source.value) ? FCRGreater : FCREqual);
            return (compareResult & expectedResult);
         });
      if (thisConstraint.constraintResult == BranchConstraint::CRRemove)
         return false;
      if (thisConstraint.constraintResult == BranchConstraint::CRStable)
         return true;
      if (thisConstraint.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         value = thisConstraint.constantResult;
         conditionalValue.reset();
         return true;
      }
      conditionalValue = std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(
         thisConstraint.simplifiedResult);
      return true;
   }
   if (!conditionalValue.get()) {
      typedef typename TIntegerWithBranches<T>::BranchConstraint BranchConstraint;
      BranchConstraint sourceConstraint = source.cconditionalValue().constraint(
         [this, expectedResult](const IntegerType& sourceVal) -> bool
         {  FullComparisonResult compareResult = (value < sourceVal) ? FCRLess : ((value > sourceVal) ? FCRGreater : FCREqual);
            return (compareResult & expectedResult);
         });
      if (sourceConstraint.constraintResult == BranchConstraint::CRRemove)
         return false;
      if (sourceConstraint.constraintResult == BranchConstraint::CRStable)
         return true;
      if (sourceConstraint.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         source.value = sourceConstraint.constantResult;
         source.conditionalValue.reset();
         return true;
      }
      source.conditionalValue = std::static_pointer_cast<TIntegerWithBranches<T>>(
         sourceConstraint.simplifiedResult);
/*
      auto sourceAndThisConstraint = source.cconditionalValue().constraint(*this,
         [expectedResult](const T& sourceVal, const IntegerType& thisVal) -> bool
         {  FullComparisonResult compareResult = (thisVal < sourceVal) ? FCRLess : ((thisVal > sourceVal) ? FCRGreater : FCREqual);
            return (compareResult & expectedResult);
         });
      if ((sourceAndThisConstraint.first.constraintResult == BranchConstraint::CRRemove)
            || (sourceAndThisConstraint.second.constraintResult == BranchConstraint::CRRemove))
         return false;
      if ((sourceAndThisConstraint.first.constraintResult == BranchConstraint::CRStable)
            && (sourceAndThisConstraint.second.constraintResult == BranchConstraint::CRStable))
         return true;
      if (sourceAndThisConstraint.first.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         source.value = sourceAndThisConstraint.first.constantResult;
         source.conditionalValue.reset();
      }
      else if (sourceAndThisConstraint.first.constraintResult == BranchConstraint::CRSimplifyWithBranch)
         source.conditionalValue = sourceAndThisConstraint.first.simplifiedResult;
      if (sourceAndThisConstraint.second.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         value = sourceAndThisConstraint.second.constantResult;
         conditionalValue.reset();
      }
      else if (sourceAndThisConstraint.second.constraintResult == BranchConstraint::CRSimplifyWithBranch)
         conditionalValue = sourceAndThisConstraint.second.simplifiedResult;
*/
      return true;
   }
   typedef typename TIntegerWithBranches<IntegerType>::BranchConstraint ThisBranchConstraint;
   typedef typename TIntegerWithBranches<T>::BranchConstraint SourceBranchConstraint;
   ThisBranchConstraint thisConstraint;
   SourceBranchConstraint sourceConstraint;
   std::tie(thisConstraint, sourceConstraint) = cconditionalValue().constraint(source.cconditionalValue(),
      std::function<bool (const IntegerType&, const T&)>(
      [expectedResult](const IntegerType& thisValue, const T& sourceValue) -> bool
      {  FullComparisonResult compareResult = (thisValue < sourceValue) ? FCRLess : ((thisValue > sourceValue) ? FCRGreater : FCREqual);
         return (compareResult & expectedResult);
      }));
   if (thisConstraint.constraintResult == ThisBranchConstraint::CRRemove
         || sourceConstraint.constraintResult == SourceBranchConstraint::CRRemove)
      return false;
   if (thisConstraint.constraintResult == ThisBranchConstraint::CRSimplifyWithConstant) {
      value = thisConstraint.constantResult;
      conditionalValue.reset();
   }
   else if (thisConstraint.constraintResult == ThisBranchConstraint::CRSimplifyWithBranch)
      conditionalValue = std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(
            thisConstraint.simplifiedResult);
   if (sourceConstraint.constraintResult == SourceBranchConstraint::CRSimplifyWithConstant) {
      source.value = sourceConstraint.constantResult;
      source.conditionalValue.reset();
   }
   else if (sourceConstraint.constraintResult == SourceBranchConstraint::CRSimplifyWithBranch)
      source.conditionalValue = std::static_pointer_cast<TIntegerWithBranches<T>>(
            sourceConstraint.simplifiedResult);
   return true;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline bool
TFldlibIntegerBranchOption<IntegerType>::followNewBranch(FullComparisonResult comparisonResult,
      FullComparisonResult trueExpectedResult) {
   int result = 0;
   bool initialDoesFollow = fDoesFollow;
   if (fDoesFollow) {
      fDoesFollow = (currentPathExplorer->currentStackPosition()
               < ((int) currentPathExplorer->stackTrace().log_base_2() - 1));
      result |= currentPathExplorer->stackTrace().cbitArray(currentPathExplorer->currentStackPosition());
   }
   else
      result = 0;
   int oldResult = result;
   currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0);
   if (!fDoesFollow) {
      ++result;
      if (result == 2)
         result = 0;
      currentPathExplorer->lastResult() = result;
      currentPathExplorer->lastLogCases() = 1;
      currentPathExplorer->lastResultCases() = 2;
      currentPathExplorer->stackTrace().bitArray(currentPathExplorer->currentStackPosition()) = oldResult & 0x1;
      if (oldResult == 0) {
         currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+1;
         currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
      };
   }
   else if (result == 0) {
      currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+1;
      currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
   };
   ++currentPathExplorer->currentStackPosition();

   if (!fDoesFollow)
      fDoesFollow = initialDoesFollow;
   return !result;
}

// could be replaced by the next more generic method
template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<int>
TFldlibIntegerBranchOption<IntegerType>::compareAsDomain(
      const TFldlibIntegerBranchOption<IntegerType>& source, FullComparisonResult result) const {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return TFldlibIntegerBranchOption<int>(false);
   if ((comparisonResult | result) == result)
      return TFldlibIntegerBranchOption<int>(true);
   TFldlibIntegerBranchOption<int> boolResult(comparisonResult & result);
   if (!conditionalValue && source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult = fullCompare(
            thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult = fullCompare(
            thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && !source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(source);
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(source);
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && source.conditionalValue
         && conditionalValue->getMergeBranchIndex() == source.conditionalValue->getMergeBranchIndex()) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(++numberOfBranches,
         false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
         std::shared_ptr<TIntegerWithBranches<int>>()));
   return boolResult;
}

// could be replaced by the next more generic method
template <typename IntegerType> requires std::integral<IntegerType>
inline bool
TFldlibIntegerBranchOption<IntegerType>::compareAsBool(
      TFldlibIntegerBranchOption<IntegerType>& source, FullComparisonResult result) {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return false;
   if ((comparisonResult | result) == FldlibBase::FCRLess)
      return true;
   bool boolResult = followNewBranch(comparisonResult, result);
   if (boolResult)
      constraintCompare(source, result /* mergedExecutionPath */);
   else
      constraintCompare(source, static_cast<FullComparisonResult>(FldlibBase::FCRAll & ~result) /* mergedExecutionPath */);
   return boolResult;
}

template <typename IntegerType> requires std::integral<IntegerType>
template <typename T> requires std::integral<T>
inline TFldlibIntegerBranchOption<int>
TFldlibIntegerBranchOption<IntegerType>::compareAsDomain(
      const TFldlibIntegerBranchOption<T>& source, FullComparisonResult result) const {
   typedef TFldlibIntegerBranchOption<T> sourceType;
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return TFldlibIntegerBranchOption<int>(false);
   if ((comparisonResult | result) == result)
      return TFldlibIntegerBranchOption<int>(true);
   TFldlibIntegerBranchOption<int> boolResult(comparisonResult & result);
   if (!conditionalValue && source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult = fullCompare(
            sourceType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult = fullCompare(
            sourceType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && !source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(source);
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(source);
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && source.conditionalValue
         && conditionalValue->getMergeBranchIndex() == source.conditionalValue->getMergeBranchIndex()) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            sourceType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult =
            sourceType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(++numberOfBranches,
         false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
         std::shared_ptr<TIntegerWithBranches<int>>()));
   return boolResult;
}

template<typename IntegerType> requires std::integral<IntegerType>
template <typename T> requires std::integral<T>
inline bool
TFldlibIntegerBranchOption<IntegerType>::compareAsBool(
      TFldlibIntegerBranchOption<T>& source, FullComparisonResult result) {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return false;
   if ((comparisonResult | result) == FldlibBase::FCRLess)
      return true;
   bool boolResult = followNewBranch(comparisonResult, result);
   if (boolResult)
      constraintCompare(source, result /* mergedExecutionPath */);
   else
      constraintCompare(source, FldlibBase::FCRAll & ~result /* mergedExecutionPath */);
   return boolResult;
}

template <typename IntegerType> requires std::integral<IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibIntegerBranchOption<IntegerType>& first, const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibIntegerBranchOption<IntegerType>&& first, const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibIntegerBranchOption<IntegerType>& first, TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibIntegerBranchOption<IntegerType>&& first, TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibIntegerBranchOption<IntegerType>& first,
         const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibIntegerBranchOption<IntegerType>&& first,
         TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename IntegerType>
TFldlibIntegerBranchOption<int>
operator<=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second)
      requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<IntegerType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<IntegerType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibIntegerBranchOption<IntegerType>& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibIntegerBranchOption<IntegerType>& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibIntegerBranchOption<IntegerType>&& first,
      const TFldlibIntegerBranchOption<T>& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibIntegerBranchOption<IntegerType>&& first,
      TFldlibIntegerBranchOption<T>&& second) requires std::integral<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename IntegerType> requires std::integral<IntegerType>
inline void
TFldlibIntegerBranchOption<IntegerType>::mergeWith(int mergeBranchIndex,
      thisType& source) {
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      if (value != source.value)
         conditionalValue.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, value,
               std::shared_ptr<TIntegerWithBranches<IntegerType>>(), source.value,
               std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
      return;
   }
   if (!conditionalValue.get()) {
      IntegerType thisValue = value;
      value = source.value;
      conditionalValue = std::move(source.conditionalValue);
      TIntegerWithBranches<IntegerType>::applyBranchAssign(mergeBranchIndex, value,
         conditionalValue, [thisValue, mergeBranchIndex](const IntegerType& sourceValue,
               std::shared_ptr<TValueWithBranches<IntegerType>>& branch)
         {  if (!branch.get()) {
               if (thisValue != sourceValue)
                  branch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>(), sourceValue,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
               return;
            }
            branch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                  std::shared_ptr<TIntegerWithBranches<IntegerType>>(), sourceValue,
                  std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(branch)));
         });
   }
   else if (!source.conditionalValue.get()) {
      TIntegerWithBranches<IntegerType>::applyBranchAssign(mergeBranchIndex, value,
         conditionalValue, [&source, mergeBranchIndex](const IntegerType& thisValue,
            std::shared_ptr<TValueWithBranches<IntegerType>>& branch)
         {  if (!branch.get()) {
               if (thisValue != source.value)
                  branch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>(), source.value,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
               return;
            }
            branch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                  std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(branch),
                  source.value, std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
         });
   }
   else {
      TIntegerWithBranches<IntegerType>::applyBranchAssign(mergeBranchIndex, value,
            conditionalValue, source.value, source.conditionalValue, [mergeBranchIndex]
            (IntegerType& thisValue, std::shared_ptr<TValueWithBranches<IntegerType>>& thisBranch,
            IntegerType& sourceValue, std::shared_ptr<TValueWithBranches<IntegerType>>& sourceBranch)
         {  if (!thisBranch.get() && !sourceBranch.get()) {
               if (thisValue != sourceValue)
                  thisBranch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>(), sourceValue,
                        std::shared_ptr<TIntegerWithBranches<IntegerType>>()));
               return;
            }
            thisBranch.reset(new TIntegerWithBranches<IntegerType>(mergeBranchIndex, thisValue,
                  std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(thisBranch), sourceValue,
                  std::static_pointer_cast<TIntegerWithBranches<IntegerType>>(sourceBranch)));
         });
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
inline void
TFldlibIntegerBranchOption<IntegerType>
   ::readImplementationSynchronizationFromFile(STG::IOObject::ISBase& inFile,
      typename BuiltDouble::ReadParameters& readParameters,
      typename Equation::ReadParameters& equationReadParameters, STG::IOObject::OSBase& outFile,
      typename BuiltDouble::WriteParameters& writeParameters,
      typename Equation::WriteParameters& equationWriteParameters,
      SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   int treeRepresentation; // TODO BigInteger
   inFile.read(treeRepresentation, false /* isRaw */);
   outFile.write(treeRepresentation, false /* isRaw */);
   AssumeCondition(treeRepresentation >= 0)
   if (!treeRepresentation) {
      conditionalValue.reset();
      inFile.read(value, false /* isRaw */);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex;
      inFile.read(mergeBranchIndex, false /* isRaw */);
      outFile.write(mergeBranchIndex, false /* isRaw */);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
      std::pair<IntegerType*, std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> branchToComplete;
      IntegerType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>> result;
      result.reset(new FldlibBase::TIntegerWithBranches<IntegerType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            inFile.read(synthesizedValue, false /* isRaw */);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            inFile.read(mergeBranchIndex, false /* isRaw */);
            outFile.write(mergeBranchIndex, false /* isRaw */);
            branchToComplete.second->reset(new FldlibBase::TIntegerWithBranches<IntegerType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      conditionalValue = result;
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>
   ::writeImplementationSynchronizationToFile(STG::IOObject::OSBase& outFile,
      const typename BuiltDouble::WriteParameters& writeParameters,
      const typename Equation::WriteParameters& equationWriteParameters) const {
   if (!conditionalValue.get()) {
      outFile.write(0, false /* isRaw */);
      outFile.write(value, false /* isRaw */);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   outFile.write(treeRepresentation, false /* isRaw */);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         outFile.write((*inheritedParentBranches.back())->getMergeBranchIndex(), false /* isRaw */);
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            outFile.write((*inheritedParentBranches.back())->getSThenValue(), false /* isRaw */);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     outFile.write((*inheritedParentBranches.back())->getSElseValue(), false /* isRaw */);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::readRealSynchronizationFromFile(
      STG::IOObject::ISBase& inFile,
      typename Equation::ReadParameters& equationReadParameters, STG::IOObject::OSBase& outFile,
      typename Equation::WriteParameters& equationWriteParameters,
      SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   int treeRepresentation; // TODO BigInteger
   inFile.read(treeRepresentation, false /* isRaw */);
   outFile.write(treeRepresentation, false /* isRaw */);
   AssumeCondition(treeRepresentation >= 0)
   if (!treeRepresentation)
      inFile.read(value, false /* isRaw */);
   else {
      --treeRepresentation;
      int mergeBranchIndex;
      inFile.read(mergeBranchIndex, false /* isRaw */);
      outFile.write(mergeBranchIndex, false /* isRaw */);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
      std::pair<IntegerType*, std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> branchToComplete;
      IntegerType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>> result;
      result.reset(new FldlibBase::TIntegerWithBranches<IntegerType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            inFile.read(synthesizedValue, false /* isRaw */);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            inFile.read(mergeBranchIndex, false /* isRaw */);
            outFile.write(mergeBranchIndex, false /* isRaw */);
            branchToComplete.second->reset(new FldlibBase::TIntegerWithBranches<IntegerType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      conditionalValue = result;
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::writeRealSynchronizationToFile(
      STG::IOObject::OSBase& outFile,
      const typename Equation::WriteParameters& equationWriteParameters) const {
   if (!conditionalValue.get()) {
      outFile.write(0, false /* isRaw */);
      outFile.write(value, false /* isRaw */);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   outFile.write(treeRepresentation, false /* isRaw */);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         outFile.write((*inheritedParentBranches.back())->getMergeBranchIndex(), false /* isRaw */);
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            outFile.write((*inheritedParentBranches.back())->getSThenValue(), false /* isRaw */);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     outFile.write((*inheritedParentBranches.back())->getSElseValue(), false /* isRaw */);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::readImplementationSynchronizationFromMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray,
      COL::TVector<int>& codeArray, SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      conditionalValue.reset();
      value = codeArray.first();
      codeArray.removeAt(0);
      codeArray.insertAtEnd(value);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
      std::pair<IntegerType*, std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> branchToComplete;
      IntegerType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>> result;
      result.reset(new FldlibBase::TIntegerWithBranches<IntegerType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(synthesizedValue);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.insertAtEnd(mergeBranchIndex);
            branchToComplete.second->reset(new FldlibBase::TIntegerWithBranches<IntegerType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      conditionalValue = result;
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::writeImplementationSynchronizationToMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   if (!conditionalValue.get()) {
      codeArray.insertAtEnd(0);
      codeArray.insertAtEnd(value);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   codeArray.insertAtEnd(treeRepresentation);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         codeArray.insertAtEnd((*inheritedParentBranches.back())->getMergeBranchIndex());
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            codeArray.insertAtEnd((*inheritedParentBranches.back())->getSThenValue());
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     codeArray.insertAtEnd((*inheritedParentBranches.back())->getSElseValue());
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::readRealSynchronizationFromMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray,
      COL::TVector<int>& codeArray, SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      value = codeArray.first();
      codeArray.removeAt(0);
      codeArray.insertAtEnd(value);
      conditionalValue.reset();
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.removeAt(0);
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
      std::pair<IntegerType*, std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> branchToComplete;
      IntegerType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>> result;
      result.reset(new FldlibBase::TIntegerWithBranches<IntegerType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(synthesizedValue);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.insertAtEnd(mergeBranchIndex);
            branchToComplete.second->reset(new FldlibBase::TIntegerWithBranches<IntegerType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TIntegerWithBranches<IntegerType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      conditionalValue = result;
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::writeRealSynchronizationToMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   if (!conditionalValue.get()) {
      codeArray.insertAtEnd(0);
      codeArray.insertAtEnd(value);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   codeArray.insertAtEnd(treeRepresentation);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         codeArray.insertAtEnd((*inheritedParentBranches.back())->getMergeBranchIndex());
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            codeArray.insertAtEnd((*inheritedParentBranches.back())->getSThenValue());
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<IntegerType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     codeArray.insertAtEnd((*inheritedParentBranches.back())->getSElseValue());
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::moveImplementationInMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      int newValue = codeArray.first();
      AssumeCondition(value == newValue)
      codeArray.removeAt(0);
      codeArray.insertAtEnd(value);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<bool> inheritedParentBranches;
      int synthesizedValue;
      inheritedParentBranches.push_back(false);

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(synthesizedValue);
            if (!inheritedParentBranches.back())
               inheritedParentBranches.back() = true;
            else {
               bool doesUp;
               do {
                  inheritedParentBranches.pop_back();
                  doesUp = (!inheritedParentBranches.empty()) ? inheritedParentBranches.back() : false;
               } while (doesUp && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(mergeBranchIndex);
            inheritedParentBranches.push_back(false);
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
   }
}

template <typename IntegerType> requires std::integral<IntegerType>
void
TFldlibIntegerBranchOption<IntegerType>::moveRealInMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      int newValue = codeArray.first();
      AssumeCondition(value == newValue)
      codeArray.removeAt(0);
      codeArray.insertAtEnd(value);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<bool> inheritedParentBranches;
      int synthesizedValue;
      inheritedParentBranches.push_back(false);

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(synthesizedValue);
            if (!inheritedParentBranches.back())
               inheritedParentBranches.back() = true;
            else {
               bool doesUp;
               do {
                  inheritedParentBranches.pop_back();
                  doesUp = (!inheritedParentBranches.empty()) ? inheritedParentBranches.back() : false;
               } while (doesUp && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(mergeBranchIndex);
            inheritedParentBranches.push_back(false);
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
   }
}

// implementation of the template class TFldlibBaseFloatingBranchOption

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::BranchCursor::setToFirst() {
   AssumeCondition(pibSupport)
   path.clear();
   vibPathParent.clear();
   vibPathParent.push_back(std::make_pair(&pibSupport->value, &pibSupport->conditionalValue));
   while (vibPathParent.back().second->get()) {
      path.push_back(std::make_pair((*vibPathParent.back().second)->getMergeBranchIndex(), true));
      vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSThenValue(),
         &(*vibPathParent.back().second)->getSThenBranch()));
   }
   return true;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::BranchCursor::setToNext() {
   AssumeCondition(pibSupport)
   if (vibPathParent.empty())
      return setToFirst();
   if (vibPathParent.size() == 1) { // root
      vibPathParent.clear();
      return false;
   }
   while (!path.empty() && path.back().second == false) {
      vibPathParent.pop_back();
      path.pop_back();
      AssumeCondition(!vibPathParent.empty())
   }
   if (!path.empty() && path.back().second == true) {
      path.back().second = false;
      vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSElseValue(),
         &(*vibPathParent.back().second)->getSElseBranch()));
      while (vibPathParent.back().second->get()) {
         path.push_back(std::make_pair((*vibPathParent.back().second)->getMergeBranchIndex(), true));
         vibPathParent.push_back(std::make_pair(&(*vibPathParent.back().second)->getSThenValue(),
            &(*vibPathParent.back().second)->getSThenBranch()));
      }
      return true;
   }
   AssumeCondition(path.empty() && vibPathParent.size() == 1)
   return true;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline void
TFldlibBaseFloatingBranchOption<FloatingType>::conditionalAssigns(
      const std::vector<std::pair<int, bool>>& path, const thisType& source) {
   if (path.empty()) {
      operator=(source);
      return;
   }
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      if (value == source.value)
         return;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(path.begin()->first,
         value, std::shared_ptr<TFloatingWithBranches<FloatingType>>(),
         value, std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.value);
      return;
   }
   if (!conditionalValue.get())
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(path.begin()->first,
         value, std::shared_ptr<TFloatingWithBranches<FloatingType>>(),
         value, std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
   if (!source.conditionalValue.get())
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.value);
   else
      cconditionalValue().conditionalAssigns(path.begin(), path.end(), source.cconditionalValue());
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+=(T source) -> thisType&
      requires enhanced_floating_point<T> || std::integral<T> {
   value += source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](FloatingType& arg) { arg += source; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+=(const thisType& source) -> thisType& {
   FloatingType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  // FloatingType sourceCopy = sourceValue;
            // sourceValue = thisValue;
            // sourceValue += sourceCopy;
            sourceValue += thisValue;
         });
      
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+=(thisType&& source) -> thisType& {
   FloatingType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue += thisValue; });
      
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+=(const TFldlibBaseFloatingBranchOption<T>& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+=(TFldlibBaseFloatingBranchOption<T>&& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value += source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue += sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue += source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator+(T second) const
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(value + second)> result(value);
   typedef TFloatingWithBranches<decltype(value + second)> FloatingBranch;
   result.value += second;
   if (conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(value + second)& resultValue) { resultValue += second; });
   }
   return result;
}

// {  TFldlibBaseFloatingBranchOption<decltype(first.value + second)> result(first.value + second);
//    if (!first.conditionalValue.get())
//       return result;
//    typedef TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
//    std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
//    result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue().getMergeBranchIndex(),
//          second, thenBranch, second, elseBranch));
//    result.cconditionalValue().applyAssign(first, 
//          [](decltype(first.value + second)& secondValue, const FloatingType& firstValue)
//       { secondValue += firstValue; });
//    return result;
// }

template <typename FloatingType, typename T>
inline auto
operator+(TFldlibBaseFloatingBranchOption<FloatingType>&& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value + second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
   result.value += second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue += second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(T first, const TFldlibBaseFloatingBranchOption<FloatingType>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) + FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first + second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first + second.value)> FloatingBranch;
   result.value += second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(T first, TFldlibBaseFloatingBranchOption<FloatingType>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) + FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first + second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first + second.value)> FloatingBranch;
   result.value += second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + T(0))> requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value + second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value += second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + T(0))> requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + T(0))> requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator+(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) + T(0))> requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value + second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value += second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value + second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value + second)> FloatingBranch;
   result.value += second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value + second)& resultValue, const T& secondValue)
               {  resultValue += secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value + second)& resultValue) { resultValue += second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value + second.value)& thisValue, const T& sourceValue)
         {  thisValue += sourceValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
operator-(const TFldlibBaseFloatingBranchOption<FloatingType>& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = -result.value;
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = -resultValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
operator-(TFldlibBaseFloatingBranchOption<FloatingType>&& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
   result.value = -result.value;
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = -resultValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator-=(T source) -> thisType&
      requires enhanced_floating_point<T> || std::integral<T> {
   value -= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](FloatingType& arg) { arg -= source; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator-=(const thisType& source) -> thisType& {
   FloatingType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  // FloatingType sourceCopy = sourceValue;
            // sourceValue = thisValue;
            // sourceValue -= sourceCopy;
            sourceValue = thisValue - sourceValue;
         });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator-=(thisType&& source) -> thisType& {
   FloatingType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue = thisValue - sourceValue; });
      
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator-=(const TFldlibBaseFloatingBranchOption<T>& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator-=(TFldlibBaseFloatingBranchOption<T>&& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value -= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue -= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue -= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return *this;
}

template <typename FloatingType, typename T>
inline auto
operator-(const TFldlibBaseFloatingBranchOption<FloatingType>& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value - second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value - second)& resultValue) { resultValue -= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(TFldlibBaseFloatingBranchOption<FloatingType>&& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value - second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue -= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(T first, const TFldlibBaseFloatingBranchOption<FloatingType>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) - FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first - second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first - second.value)> FloatingBranch;
   result.value -= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(T first, TFldlibBaseFloatingBranchOption<FloatingType>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) - FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first - second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first - second.value)> FloatingBranch;
   result.value -= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value - second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(first);
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value - second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - T(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator-(TFldlibBaseFloatingBranchOption<FloatingType>&& first, TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) - T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value - second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value -= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value - second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value - second)> FloatingBranch;
   result.value -= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value - second)& resultValue, const T& secondValue)
               {  resultValue -= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value - second)& resultValue) { resultValue -= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value - second.value)& thisValue, const T& sourceValue)
         {  thisValue -= sourceValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline TFldlibBaseFloatingBranchOption<FloatingType>&
TFldlibBaseFloatingBranchOption<FloatingType>::operator*=(T source)
      requires enhanced_floating_point<T> || std::integral<T> {
   value *= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](FloatingType& arg) { arg *= source; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator*=(const thisType& source) -> thisType& {
   FloatingType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get()) {
         auto function =[](FloatingType& thisValue, const FloatingType& sourceValue) -> void { thisValue *= sourceValue; };
         cconditionalValue().applyAssign(source.cconditionalValue(), function);
      }
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) -> void { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue *= thisValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator*=(thisType&& source) -> thisType& {
   FloatingType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue *= thisValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator*=(const TFldlibBaseFloatingBranchOption<T>& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator*=(TFldlibBaseFloatingBranchOption<T>&& source) -> thisType&
      requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value *= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue *= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue *= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return *this;
}

template <typename FloatingType, typename T>
inline auto
operator*(const TFldlibBaseFloatingBranchOption<FloatingType>& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) * typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value * second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value * second)& resultValue) { resultValue *= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(TFldlibBaseFloatingBranchOption<FloatingType>&& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) * typename EFloatingPointType<T>::base_type(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value * second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value * second)& resultValue) { resultValue *= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(T first, const TFldlibBaseFloatingBranchOption<FloatingType>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) * FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first * second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first * second.value)> FloatingBranch;
   result.value *= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first * second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(T first, TFldlibBaseFloatingBranchOption<FloatingType>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) * FloatingType(0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first * second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first * second.value)> FloatingBranch;
   result.value *= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first * second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) * T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value * second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(first);
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) * T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value * second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator*(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0.0) * T(0.0))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}


template <typename FloatingType, typename T>
inline auto
operator*(TFldlibBaseFloatingBranchOption<FloatingType>&& first, TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) * T(0))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value * second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value *= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value * second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value * second)> FloatingBranch;
   result.value *= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value * second)& resultValue, const T& secondValue)
               {  resultValue *= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value * second)& resultValue) { resultValue *= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value * second.value)& thisValue, const T& sourceValue)
         {  thisValue *= sourceValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator/=(T source) -> thisType&
      requires enhanced_floating_point<T> || std::integral<T> {
   value /= source;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      cconditionalValue().applyAssign([source](FloatingType& arg) { arg /= source; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator/=(const thisType& source) -> thisType& {
   FloatingType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue = thisValue / sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator/=(thisType&& source) -> thisType& {
   FloatingType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.cconditionalValue()));
      cconditionalValue().applyAssign([thisValue](FloatingType& sourceValue)
         {  sourceValue = thisValue / sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator/=(const TFldlibBaseFloatingBranchOption<T>& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return *this;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::operator/=(TFldlibBaseFloatingBranchOption<T>&& source)
      -> thisType& requires enhanced_floating_point<T> {
   FloatingType thisValue = value;
   value /= source.value;
   if (conditionalValue.get()) {
      if (conditionalValue.use_count() > 1)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(cconditionalValue()));
      if (source.conditionalValue.get())
         cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue /= sourceValue; });
      else
         cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue /= source.value; });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      conditionalValue.reset(new TFloatingWithBranches<FloatingType>(source.getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      cconditionalValue().applyAssign([&source](FloatingType& thisValue, const FloatingType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return *this;
}

template <typename FloatingType, typename T>
inline auto
operator/(const TFldlibBaseFloatingBranchOption<FloatingType>& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / typename EFloatingPointType<T>::base_type(1))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value / second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value / second)& resultValue) { resultValue /= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(TFldlibBaseFloatingBranchOption<FloatingType>&& first, T second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / typename EFloatingPointType<T>::base_type(1))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value / second)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (decltype(first.value + second)& resultValue) { resultValue /= second; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(T first, const TFldlibBaseFloatingBranchOption<FloatingType>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) / FloatingType(1))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first / second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first / second.value)> FloatingBranch;
   result.value /= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(T first, TFldlibBaseFloatingBranchOption<FloatingType>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(typename EFloatingPointType<T>::base_type(0) / FloatingType(1))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first / second.value)> result(first);
   typedef FldlibBase::TFloatingWithBranches<decltype(first / second.value)> FloatingBranch;
   result.value /= second.value;
   if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first, thenBranch, first, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first + second.value)& thisValue, const FloatingType& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / T(1))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value / second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(first);
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / T(1))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value / second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / T(1))>
      requires enhanced_floating_point<T> {
   TFldlibBaseFloatingBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType, typename T>
inline auto
operator/(TFldlibBaseFloatingBranchOption<FloatingType>&& first, TFldlibBaseFloatingBranchOption<T>&& second)
      -> TFldlibBaseFloatingBranchOption<decltype(FloatingType(0) / T(1))>
      requires enhanced_floating_point<T> {
   if (std::is_same<decltype(first.value / second.value), FloatingType>::value) {
      TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
      result.value /= second.value;
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else if (result.conditionalValue.get())
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
      return result;
   };
   TFldlibBaseFloatingBranchOption<decltype(first.value / second.value)> result(first.value);
   typedef FldlibBase::TFloatingWithBranches<decltype(first.value / second)> FloatingBranch;
   result.value /= second.value;
   if (first.conditionalValue.get()) {
      result.conditionalValue.reset(new FloatingBranch(first.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(), []
            (decltype(first.value / second)& resultValue, const T& secondValue)
               {  resultValue /= secondValue; });
      else
         result.cconditionalValue().applyAssign([second]
            (decltype(first.value / second)& resultValue) { resultValue /= second.value; });
   }
   else if (second.conditionalValue.get()) {
      std::shared_ptr<FloatingBranch> thenBranch, elseBranch;
      result.conditionalValue.reset(new FloatingBranch(second.cconditionalValue().getMergeBranchIndex(),
            first.value, thenBranch, first.value, elseBranch));
      result.cconditionalValue().applyAssign(second.cconditionalValue(),
         [](decltype(first.value / second.value)& thisValue, const T& sourceValue)
         {  thisValue /= sourceValue; });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T> requires enhanced_floating_point<T>
inline auto
TFldlibBaseFloatingBranchOption<FloatingType>::fullCompare(const TFldlibBaseFloatingBranchOption<T>& source) const
      -> FullComparisonResult {
   if (!conditionalValue.get() && !source.conditionalValue.get())
      return (value < source.value) ? FCRLess : ((value > source.value) ? FCRGreater : FCREqual);
   FullComparisonResult result = FCRUndefined;
   if (!source.conditionalValue.get()) {
      cconditionalValue().apply([&result, &source](const FloatingType& val)
         {  if (val < source.value)
               result = (FullComparisonResult) (result | FCRLess);
            else if (val > source.value)
               result = (FullComparisonResult) (result | FCRGreater);
            else
               result = (FullComparisonResult) (result | FCREqual);
         });
      return result;
   }
   if (!conditionalValue.get()) {
      source.cconditionalValue().apply([&result, this](const T& sourceVal)
         {  if (value < sourceVal)
               result = (FullComparisonResult) (result | FCRLess);
            else if (value > sourceVal)
               result = (FullComparisonResult) (result | FCRGreater);
            else
               result = (FullComparisonResult) (result | FCREqual);
         });
      return result;
   }
   cconditionalValue().apply(source.cconditionalValue(),
      std::function<void (const FloatingType&, const T&)>(
      [&result](const FloatingType& thisValue, const T& sourceValue) -> void
      {  if (thisValue < sourceValue)
            result = (FullComparisonResult) (result | FCRLess);
         else if (thisValue > sourceValue)
            result = (FullComparisonResult) (result | FCRGreater);
         else
            result = (FullComparisonResult) (result | FCREqual);
      }));
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template<typename T>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::constraintCompare(TFldlibBaseFloatingBranchOption<T>& source,
      FullComparisonResult expectedResult
      /* , MergedExecutionPath& mergedExecutionPath could remove some BranchInformation in branchDictionary*/) {
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      FullComparisonResult compareResult = (value < source.value) ? FCRLess : ((value > source.value) ? FCRGreater : FCREqual);
      return (compareResult & expectedResult);
   }
   if (!source.conditionalValue.get()) {
      typedef typename TFloatingWithBranches<FloatingType>::BranchConstraint BranchConstraint;
      BranchConstraint thisConstraint = cconditionalValue().constraint(
         [&source, expectedResult](const FloatingType& val) -> bool
         {  FullComparisonResult compareResult = (val < source.value) ? FCRLess : ((val > source.value) ? FCRGreater : FCREqual);
            return (compareResult & expectedResult);
         });
      if (thisConstraint.constraintResult == BranchConstraint::CRRemove)
         return false;
      if (thisConstraint.constraintResult == BranchConstraint::CRStable)
         return true;
      if (thisConstraint.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         value = thisConstraint.constantResult;
         conditionalValue.reset();
         return true;
      }
      conditionalValue = std::static_pointer_cast<TFloatingWithBranches<FloatingType>>(
         thisConstraint.simplifiedResult);
      return true;
   }
   if (!conditionalValue.get()) {
      typedef typename TFloatingWithBranches<T>::BranchConstraint BranchConstraint;
      BranchConstraint sourceConstraint = source.cconditionalValue().constraint(
         [this, expectedResult](const FloatingType& sourceVal) -> bool
         {  FullComparisonResult compareResult = (value < sourceVal) ? FCRLess : ((value > sourceVal) ? FCRGreater : FCREqual);
            return (compareResult & expectedResult);
         });
      if (sourceConstraint.constraintResult == BranchConstraint::CRRemove)
         return false;
      if (sourceConstraint.constraintResult == BranchConstraint::CRStable)
         return true;
      if (sourceConstraint.constraintResult == BranchConstraint::CRSimplifyWithConstant) {
         source.value = sourceConstraint.constantResult;
         source.conditionalValue.reset();
         return true;
      }
      source.conditionalValue = std::static_pointer_cast<TFloatingWithBranches<T>>(
         sourceConstraint.simplifiedResult);
      return true;
   }
   typedef typename TFloatingWithBranches<FloatingType>::BranchConstraint ThisBranchConstraint;
   typedef typename TFloatingWithBranches<T>::BranchConstraint SourceBranchConstraint;
   ThisBranchConstraint thisConstraint;
   SourceBranchConstraint sourceConstraint;
   std::tie(thisConstraint, sourceConstraint) = cconditionalValue().constraint(source.cconditionalValue(),
      std::function<bool (const FloatingType&, const T&)>(
      [expectedResult](const FloatingType& thisValue, const T& sourceValue) -> bool
      {  FullComparisonResult compareResult = (thisValue < sourceValue) ? FCRLess : ((thisValue > sourceValue) ? FCRGreater : FCREqual);
         return (compareResult & expectedResult);
      }));
   if (thisConstraint.constraintResult == ThisBranchConstraint::CRRemove
         || sourceConstraint.constraintResult == SourceBranchConstraint::CRRemove)
      return false;
   if (thisConstraint.constraintResult == ThisBranchConstraint::CRSimplifyWithConstant) {
      value = thisConstraint.constantResult;
      conditionalValue.reset();
   }
   else if (thisConstraint.constraintResult == ThisBranchConstraint::CRSimplifyWithBranch)
      conditionalValue = std::static_pointer_cast<TFloatingWithBranches<FloatingType>>(
         thisConstraint.simplifiedResult);
   if (sourceConstraint.constraintResult == SourceBranchConstraint::CRSimplifyWithConstant) {
      source.value = sourceConstraint.constantResult;
      source.conditionalValue.reset();
   }
   else if (sourceConstraint.constraintResult == SourceBranchConstraint::CRSimplifyWithBranch)
      source.conditionalValue = std::static_pointer_cast<TFloatingWithBranches<T>>(
         sourceConstraint.simplifiedResult);
   return true;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::followNewBranch(FullComparisonResult comparisonResult,
      FullComparisonResult trueExpectedResult) {
   int result = 0;
   bool initialDoesFollow = fDoesFollow;
   if (fDoesFollow) {
      fDoesFollow = (currentPathExplorer->currentStackPosition()
               < ((int) currentPathExplorer->stackTrace().log_base_2() - 1));
      result |= currentPathExplorer->stackTrace().cbitArray(currentPathExplorer->currentStackPosition());
   }
   else
      result = 0;
   int oldResult = result;
   currentPathExplorer->doesCurrentUnstableHasOtherBranches() = (result == 0);
   if (!fDoesFollow) {
      ++result;
      if (result == 2)
         result = 0;
      currentPathExplorer->lastResult() = result;
      currentPathExplorer->lastLogCases() = 1;
      currentPathExplorer->lastResultCases() = 2;
      currentPathExplorer->stackTrace().bitArray(currentPathExplorer->currentStackPosition()) = oldResult & 0x1;
      if (oldResult == 0) {
         currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+1;
         currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
      };
   }
   else if (result == 0) {
      currentPathExplorer->lastZeroBit() = currentPathExplorer->currentStackPosition()+1;
      currentPathExplorer->lastIncBit() = currentPathExplorer->currentStackPosition();
   };
   ++currentPathExplorer->currentStackPosition();

   if (!fDoesFollow)
      fDoesFollow = initialDoesFollow;
   return !result;
}

// could be replaced by the next more generic method
template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline TFldlibIntegerBranchOption<int>
TFldlibBaseFloatingBranchOption<FloatingType>::compareAsDomain(
      const TFldlibBaseFloatingBranchOption<FloatingType>& source, FullComparisonResult result) const {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return TFldlibIntegerBranchOption<int>(false);
   if ((comparisonResult | result) == result)
      return TFldlibIntegerBranchOption<int>(true);
   TFldlibIntegerBranchOption<int> boolResult(comparisonResult & result);
   if (!conditionalValue && source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult = fullCompare(
            thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult = fullCompare(
            thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && !source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(source);
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(source);
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && source.conditionalValue
         && conditionalValue->getMergeBranchIndex() == source.conditionalValue->getMergeBranchIndex()) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(++numberOfBranches,
         false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
         std::shared_ptr<TIntegerWithBranches<int>>()));
   return boolResult;
}

// could be replaced by the next more generic method
template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::compareAsBool(
      TFldlibBaseFloatingBranchOption<FloatingType>& source, FullComparisonResult result) {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return false;
   if ((comparisonResult | result) == FldlibBase::FCRLess)
      return true;
   bool boolResult = followNewBranch(comparisonResult, result);
   if (boolResult)
      constraintCompare(source, result /* mergedExecutionPath */);
   else
      constraintCompare(source, static_cast<FullComparisonResult>(FldlibBase::FCRAll & ~result) /* mergedExecutionPath */);
   return boolResult;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T> requires enhanced_floating_point<T>
inline TFldlibIntegerBranchOption<int>
TFldlibBaseFloatingBranchOption<FloatingType>::compareAsDomain(
      const TFldlibBaseFloatingBranchOption<T>& source, FullComparisonResult result) const {
   typedef TFldlibBaseFloatingBranchOption<T> sourceType;
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return TFldlibIntegerBranchOption<int>(false);
   if ((comparisonResult | result) == result)
      return TFldlibIntegerBranchOption<int>(true);
   TFldlibIntegerBranchOption<int> boolResult(comparisonResult & result);
   if (!conditionalValue && source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult = fullCompare(
            sourceType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult = fullCompare(
            sourceType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(source.conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && !source.conditionalValue) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            thisType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(source);
      FldlibBase::FullComparisonResult elseComparisonResult =
            thisType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(source);
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   else if (conditionalValue && source.conditionalValue
         && conditionalValue->getMergeBranchIndex() == source.conditionalValue->getMergeBranchIndex()) {
      FldlibBase::FullComparisonResult thenComparisonResult =
            sourceType(conditionalValue->getSThenValue(), conditionalValue->getSThenBranch())
               .fullCompare(thisType(source.conditionalValue->getSThenValue(), source.conditionalValue->getSThenBranch()));
      FldlibBase::FullComparisonResult elseComparisonResult =
            sourceType(conditionalValue->getSElseValue(), conditionalValue->getSElseBranch())
               .fullCompare(thisType(source.conditionalValue->getSElseValue(), source.conditionalValue->getSElseBranch()));
      if ((thenComparisonResult | result) == result && (elseComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               true, std::shared_ptr<TIntegerWithBranches<int>>(), false,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
      if ((elseComparisonResult | result) == result && (thenComparisonResult & result) == 0) {
         boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(conditionalValue->getMergeBranchIndex(),
               false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
               std::shared_ptr<TIntegerWithBranches<int>>()));
         return boolResult;
      }
   }
   boolResult.conditionalValue.reset(new TIntegerWithBranches<int>(++numberOfBranches,
         false, std::shared_ptr<TIntegerWithBranches<int>>(), true,
         std::shared_ptr<TIntegerWithBranches<int>>()));
   return boolResult;
}

template<typename FloatingType> requires enhanced_floating_point<FloatingType>
template <typename T> requires enhanced_floating_point<T>
inline bool
TFldlibBaseFloatingBranchOption<FloatingType>::compareAsBool(
      TFldlibBaseFloatingBranchOption<T>& source, FullComparisonResult result) {
   FldlibBase::FullComparisonResult comparisonResult = fullCompare(source);
   if ((comparisonResult & result) == 0)
      return false;
   if ((comparisonResult | result) == FldlibBase::FCRLess)
      return true;
   bool boolResult = followNewBranch(comparisonResult, result);
   if (boolResult)
      constraintCompare(source, result /* mergedExecutionPath */);
   else
      constraintCompare(source, FldlibBase::FCRAll & ~result /* mergedExecutionPath */);
   return boolResult;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline std::vector<int>
TFldlibBaseFloatingBranchOption<FloatingType>::fullDiscreteConvert() const {
   if (!conditionalValue.get())
      return std::vector<int>{ value };
   std::vector<int> result;
   cconditionalValue().apply([&result](const FloatingType& val)
      {  int res = val;
         bool isFound = false;
         for (const auto& content : result) {
            if (content == val) {
               isFound = true;
               break;
            }
         }
         if (!isFound)
            result.push_back(res);
      });
   return result;
}

template <typename FloatingType>
inline bool
operator<(const TFldlibBaseFloatingBranchOption<FloatingType>& first, const TFldlibBaseFloatingBranchOption<FloatingType>& second) {
   typedef TFldlibBaseFloatingBranchOption<FloatingType> thisType;
   FldlibBase::FullComparisonResult comparisonResult = first.fullCompare(second);
   if ((comparisonResult & FldlibBase::FCRLess) == 0)
      return false;
   if ((comparisonResult | FldlibBase::FCRLess) == FldlibBase::FCRLess)
      return true;
   bool result = first.followNewBranch(comparisonResult, FldlibBase::FCRLess);
   if (result)
      const_cast<thisType&>(first).constraintCompare(const_cast<thisType&>(second),
         FldlibBase::FCRLess /* mergedExecutionPath */);
   else
      const_cast<thisType&>(first).constraintCompare(const_cast<thisType&>(second),
         FldlibBase::FCRGreaterOrEqual /* mergedExecutionPath */);
   return result;
}

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibBaseFloatingBranchOption<FloatingType>&& first, const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibBaseFloatingBranchOption<FloatingType>& first, TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibBaseFloatingBranchOption<FloatingType>&& first, TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
         const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
         TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLess); }

template <typename FloatingType>
TFldlibIntegerBranchOption<int>
operator<=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator<=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRLessOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second)
      requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator==(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCREqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator!=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRDifferent); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>=(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreaterOrEqual); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<FloatingType>&& second)
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      const TFldlibBaseFloatingBranchOption<T>& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType, typename T>
inline TFldlibIntegerBranchOption<int>
operator>(TFldlibBaseFloatingBranchOption<FloatingType>&& first,
      TFldlibBaseFloatingBranchOption<T>&& second) requires enhanced_floating_point<T>
{  return first.compareAsDomain(second, FldlibBase::FCRGreater); }

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline void
TFldlibBaseFloatingBranchOption<FloatingType>::mergeWith(int mergeBranchIndex,
      thisType& source) {
   if (!conditionalValue.get() && !source.conditionalValue.get()) {
      if (value != source.value)
         conditionalValue.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, value,
               std::shared_ptr<TFloatingWithBranches<FloatingType>>(), source.value,
               std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
      return;
   }
   if (!conditionalValue.get()) {
      FloatingType thisValue = value;
      value = source.value;
      conditionalValue = std::move(source.conditionalValue);
      TFloatingWithBranches<FloatingType>::applyBranchAssign(mergeBranchIndex, value,
            conditionalValue,
         [thisValue, mergeBranchIndex]
         (const FloatingType& sourceValue,
            std::shared_ptr<TFloatingWithBranches<FloatingType>>& branch)
         {  if (!branch.get()) {
               if (thisValue != sourceValue)
                  branch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                        std::shared_ptr<TFloatingWithBranches<FloatingType>>(), sourceValue,
                        std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
               return;
            }
            branch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                  std::shared_ptr<TFloatingWithBranches<FloatingType>>(), sourceValue,
                  branch));
         });
   }
   else if (!source.conditionalValue.get()) {
      TFloatingWithBranches<FloatingType>::applyBranchAssign(mergeBranchIndex, value,
            conditionalValue,
         [&source, mergeBranchIndex]
         (const FloatingType& thisValue,
            std::shared_ptr<TFloatingWithBranches<FloatingType>>& branch)
         {  if (!branch.get()) {
               if (thisValue != source.value)
                  branch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                        std::shared_ptr<TFloatingWithBranches<FloatingType>>(), source.value,
                        std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
               return;
            }
            branch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                  branch, source.value, std::shared_ptr<TFloatingWithBranches<FloatingType>>()));
         });
   }
   else {
      TFloatingWithBranches<FloatingType>::applyBranchAssign(mergeBranchIndex, value,
            conditionalValue, source.value, source.conditionalValue,
         [mergeBranchIndex](FloatingType& thisValue,
            std::shared_ptr<TFloatingWithBranches<FloatingType>>& thisBranch,
            FloatingType& sourceValue, std::shared_ptr<TFloatingWithBranches<FloatingType>>& sourceBranch)
         {  if (!thisBranch.get() && !sourceBranch.get()) {
               if (thisValue != sourceValue)
                  thisBranch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                        thisBranch, sourceValue, sourceBranch));
               return;
            }
            thisBranch.reset(new TFloatingWithBranches<FloatingType>(mergeBranchIndex, thisValue,
                  thisBranch, sourceValue, sourceBranch));
         });
   }
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
abs(const TFldlibBaseFloatingBranchOption<FloatingType>& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = abs(result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = abs(resultValue); });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
abs(TFldlibBaseFloatingBranchOption<FloatingType>&& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
   result.value = abs(result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = abs(resultValue); });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
sqrt(const TFldlibBaseFloatingBranchOption<FloatingType>& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = sqrt(result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = sqrt(resultValue); });
   }
   return result;
}

template <typename FloatingType> requires enhanced_floating_point<FloatingType>
inline auto
sqrt(TFldlibBaseFloatingBranchOption<FloatingType>&& first) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
   result.value = sqrt(result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([]
         (FloatingType& resultValue) { resultValue = sqrt(resultValue); });
   }
   return result;
}

template <typename FloatingType, typename T>
requires enhanced_floating_point<FloatingType> and std::integral<T>
inline auto
pow(const TFldlibBaseFloatingBranchOption<FloatingType>& first, T second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = pow(result.value, second);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (FloatingType& resultValue) { resultValue = pow(resultValue, second); });
   }
   return result;
}

template <typename FloatingType, typename T>
requires enhanced_floating_point<FloatingType> and std::integral<T>
inline auto
pow(TFldlibBaseFloatingBranchOption<FloatingType>&& first, T second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(std::move(first));
   result.value = pow(result.value, second);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([second]
         (FloatingType& resultValue) { resultValue = pow(resultValue, second); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
min(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = fmin(result.value, second.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(),
            [](FloatingType& resultValue, const FloatingType& secondValue)
            { resultValue = fmin(resultValue, secondValue); });
      else
         result.cconditionalValue().applyAssign(
            [&second](FloatingType& resultValue) { resultValue = fmin(resultValue, second.value); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
min(const TFldlibBaseFloatingBranchOption<FloatingType>& first, const FloatingType& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = fmin(result.value, second);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([&second]
         (FloatingType& resultValue) { resultValue = fmin(resultValue, second); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
min(const FloatingType& first, const TFldlibBaseFloatingBranchOption<FloatingType>& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(second);
   result.value = fmin(first, result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([&first]
         (FloatingType& resultValue) { resultValue = fmin(first, resultValue); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
max(const TFldlibBaseFloatingBranchOption<FloatingType>& first,
      const TFldlibBaseFloatingBranchOption<FloatingType>& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = fmax(result.value, second.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      if (second.conditionalValue.get())
         result.cconditionalValue().applyAssign(second.cconditionalValue(),
            [](FloatingType& resultValue, const FloatingType& secondValue)
            { resultValue = fmax(resultValue, secondValue); });
      else
         result.cconditionalValue().applyAssign(
            [&second](FloatingType& resultValue) { resultValue = fmax(resultValue, second.value); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
max(const TFldlibBaseFloatingBranchOption<FloatingType>& first, const FloatingType& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(first);
   result.value = fmax(result.value, second);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([&second]
         (FloatingType& resultValue) { resultValue = fmax(resultValue, second); });
   }
   return result;
}

template <typename FloatingType>
requires enhanced_floating_point<FloatingType>
inline auto
max(const FloatingType& first, const TFldlibBaseFloatingBranchOption<FloatingType>& second) -> TFldlibBaseFloatingBranchOption<FloatingType> {
   TFldlibBaseFloatingBranchOption<FloatingType> result(second);
   result.value = fmax(first, result.value);
   if (result.conditionalValue.get()) {
      result.conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(result.cconditionalValue()));
      result.cconditionalValue().applyAssign([&first]
         (FloatingType& resultValue) { resultValue = fmax(first, resultValue); });
   }
   return result;
}

template <typename DoubleType> requires std::floating_point<DoubleType>
inline std::vector<int>
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::fullDiscreteConvert(const TFldlibZonotopeOption<DoubleType>& source) {
   if (!source.zonotope)
      return std::vector<int>{ (int) source.value };
   int realResultMin, realResultMax, implementationResultMin, implementationResultMax,
      realPlusErrorResultMin, realPlusErrorResultMax,
      implementationBoundResultMin, implementationBoundResultMax;

   int baseResult;
   unsigned firstReal, lastReal, firstImplementation, lastImplementation;
   typename TFldlibZonotopeOption<DoubleType>::EquationHolder implementation;
   if (source.zonotope->retrieveConcreteChoicesForConversion(Numerics::DDouble::Access::ReadParameters::RMZero, implementation,
            baseResult, firstReal, lastReal, firstImplementation, lastImplementation,
            realResultMin, realResultMax, implementationResultMin, implementationResultMax,
            realPlusErrorResultMin, realPlusErrorResultMax, implementationBoundResultMin,
            implementationBoundResultMax))
      return std::vector<int>({ baseResult });
   int maxValue = std::max(realResultMax, implementationBoundResultMax);
   std::vector<int> result;
   while (baseResult <= maxValue) {
      result.push_back(baseResult);
      ++baseResult;
   };
   return result;
}

template <typename DoubleType> requires std::floating_point<DoubleType>
inline std::vector<int>
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::fullDiscreteConvert() const {
   if (!this->conditionalValue.get())
      return fullDiscreteConvert(this->value);
   std::vector<int> result;
   this->cconditionalValue().apply([&result](const TFldlibZonotopeOption<DoubleType>& val)
      {  std::vector<int> localResult = fullDiscreteConvert(val);
         for (auto res : localResult) {
            bool isFound = false;
            for (const auto& content : result) {
               if (content == val) {
                  isFound = true;
                  break;
               }
            }
            if (!isFound)
               result.push_back(res);
         }
      });
   return result;
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::mergeWith(const thisType& source) {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   FloatingType thisValue = inherited::value;
   inherited::value.mergeWith(source.value);
   if (inherited::conditionalValue.get()) {
      if (inherited::conditionalValue.use_count() > 1)
         inherited::conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(inherited::cconditionalValue()));
      if (source.conditionalValue.get())
         inherited::cconditionalValue().applyAssign(source.cconditionalValue(),
               [](FloatingType& thisValue, const FloatingType& sourceValue) { thisValue.mergeWith(sourceValue); });
      else
         inherited::cconditionalValue().applyAssign(
               [&source](FloatingType& thisValue) { thisValue.mergeWith(source.value); });
   }
   else if (source.conditionalValue.get()) {
      std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>> thenBranch, elseBranch;
      inherited::conditionalValue.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(
            source.conditionalValue->getMergeBranchIndex(),
            thisValue, thenBranch, thisValue, elseBranch));
      inherited::cconditionalValue().applyAssign(
            [&source](FloatingType& thisValue) { thisValue.mergeWith(source.value); });
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>
   ::readImplementationSynchronizationFromFile(STG::IOObject::ISBase& inFile,
      typename BuiltDouble::ReadParameters& readParameters,
      typename Equation::ReadParameters& equationReadParameters, STG::IOObject::OSBase& outFile,
      typename BuiltDouble::WriteParameters& writeParameters,
      typename Equation::WriteParameters& equationWriteParameters,
      SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation; // TODO BigInteger
   inFile.read(treeRepresentation, false /* isRaw */);
   outFile.write(treeRepresentation, false /* isRaw */);
   AssumeCondition(treeRepresentation >= 0)
   if (!treeRepresentation) {
      inherited::conditionalValue.reset();
      inherited::value.readImplementationSynchronizationFromFile(inFile, readParameters,
            equationReadParameters, outFile, writeParameters, equationWriteParameters,
            symbolsManager, highLevelError);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex;
      inFile.read(mergeBranchIndex, false /* isRaw */);
      outFile.write(mergeBranchIndex, false /* isRaw */);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
      std::pair<FloatingType*, std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> branchToComplete;
      FloatingType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>> result;
      result.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.readImplementationSynchronizationFromFile(inFile, readParameters, equationReadParameters,
                  outFile, writeParameters, equationWriteParameters, symbolsManager, highLevelError);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            inFile.read(mergeBranchIndex, false /* isRaw */);
            outFile.write(mergeBranchIndex, false /* isRaw */);
            branchToComplete.second->reset(new FldlibBase::TFloatingWithBranches<FloatingType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      inherited::conditionalValue = result;
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>
   ::writeImplementationSynchronizationToFile(STG::IOObject::OSBase& outFile,
      const typename BuiltDouble::WriteParameters& writeParameters,
      const typename Equation::WriteParameters& equationWriteParameters) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   if (!inherited::conditionalValue.get()) {
      outFile.write(0, false /* isRaw */);
      inherited::value.writeImplementationSynchronizationToFile(outFile, writeParameters,
            equationWriteParameters);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   outFile.write(treeRepresentation, false /* isRaw */);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         outFile.write((*inheritedParentBranches.back())->getMergeBranchIndex(), false /* isRaw */);
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            (*inheritedParentBranches.back())->getSThenValue().writeImplementationSynchronizationToFile(
                  outFile, writeParameters, equationWriteParameters);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     (*inheritedParentBranches.back())->getSElseValue().writeImplementationSynchronizationToFile(
                           outFile, writeParameters, equationWriteParameters);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>
   ::readRealSynchronizationFromFile(STG::IOObject::ISBase& inFile,
      typename Equation::ReadParameters& equationReadParameters, STG::IOObject::OSBase& outFile,
      typename Equation::WriteParameters& equationWriteParameters,
      SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation; // TODO BigInteger
   inFile.read(treeRepresentation, false /* isRaw */);
   outFile.write(treeRepresentation, false /* isRaw */);
   AssumeCondition(treeRepresentation >= 0)
   if (!treeRepresentation) {
      inherited::value.readRealSynchronizationFromFile(inFile, equationReadParameters, outFile,
            equationWriteParameters, symbolsManager, highLevelError);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex;
      inFile.read(mergeBranchIndex, false /* isRaw */);
      outFile.write(mergeBranchIndex, false /* isRaw */);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
      std::pair<FloatingType*, std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> branchToComplete;
      FloatingType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>> result;
      result.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.readRealSynchronizationFromFile(inFile, equationReadParameters,
                  outFile, equationWriteParameters, symbolsManager, highLevelError);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            inFile.read(mergeBranchIndex, false /* isRaw */);
            outFile.write(mergeBranchIndex, false /* isRaw */);
            branchToComplete.second->reset(new FldlibBase::TFloatingWithBranches<FloatingType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      inherited::conditionalValue = result;
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>
   ::writeRealSynchronizationToFile(STG::IOObject::OSBase& outFile,
      const typename Equation::WriteParameters& equationWriteParameters) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   if (!inherited::conditionalValue.get()) {
      outFile.write(0, false /* isRaw */);
      inherited::value.writeRealSynchronizationToFile(outFile, equationWriteParameters);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   outFile.write(treeRepresentation, false /* isRaw */);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         outFile.write((*inheritedParentBranches.back())->getMergeBranchIndex(), false /* isRaw */);
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            (*inheritedParentBranches.back())->getSThenValue().writeRealSynchronizationToFile(
                  outFile, equationWriteParameters);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     (*inheritedParentBranches.back())->getSElseValue().writeRealSynchronizationToFile(
                           outFile, equationWriteParameters);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::readImplementationSynchronizationFromMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray,
      COL::TVector<int>& codeArray, SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      inherited::conditionalValue.reset();
      inherited::value.readImplementationSynchronizationFromMemory(
            implementationArray, equationArray, codeArray, symbolsManager, highLevelError);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
      std::pair<FloatingType*, std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> branchToComplete;
      FloatingType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>> result;
      result.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.readImplementationSynchronizationFromMemory(
                  implementationArray, equationArray, codeArray, symbolsManager, highLevelError);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.insertAtEnd(mergeBranchIndex);
            branchToComplete.second->reset(new FldlibBase::TFloatingWithBranches<FloatingType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      inherited::conditionalValue = result;
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::writeImplementationSynchronizationToMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   if (!inherited::conditionalValue.get()) {
      codeArray.insertAtEnd(0);
      inherited::value.writeImplementationSynchronizationToMemory(implementationArray,
            equationArray, codeArray);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   codeArray.insertAtEnd(treeRepresentation);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         codeArray.insertAtEnd((*inheritedParentBranches.back())->getMergeBranchIndex());
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            (*inheritedParentBranches.back())->getSThenValue().writeImplementationSynchronizationToMemory(
                  implementationArray, equationArray, codeArray);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     (*inheritedParentBranches.back())->getSElseValue().writeImplementationSynchronizationToMemory(
                           implementationArray, equationArray, codeArray);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::readRealSynchronizationFromMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray,
      COL::TVector<int>& codeArray, SymbolsManager& symbolsManager, BuiltReal& highLevelError) {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      inherited::conditionalValue.reset();
      inherited::value.readRealSynchronizationFromMemory(equationArray, codeArray, symbolsManager,
            highLevelError);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
      std::pair<FloatingType*, std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> branchToComplete;
      FloatingType synthesizedValue;
      std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>> result;
      result.reset(new FldlibBase::TFloatingWithBranches<FloatingType>(mergeBranchIndex,
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
            synthesizedValue, std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
      inheritedParentBranches.push_back(&result);
      branchToComplete = std::make_pair(&result->getSThenValue(), &result->getSThenBranch());

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.readRealSynchronizationFromMemory(
                  equationArray, codeArray, symbolsManager, highLevelError);
            *branchToComplete.first = synthesizedValue;
            if (&(*inheritedParentBranches.back())->getSThenValue() == branchToComplete.first
                  && &(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second)
               branchToComplete = std::make_pair(
                  &(*inheritedParentBranches.back())->getSElseValue(),
                  &(*inheritedParentBranches.back())->getSElseBranch());
            else {
               AssumeCondition(&(*inheritedParentBranches.back())->getSElseValue() == branchToComplete.first
                     && &(*inheritedParentBranches.back())->getSElseBranch() == branchToComplete.second)
               do {
                  branchToComplete.first = nullptr;
                  branchToComplete.second = inheritedParentBranches.back();
                  inheritedParentBranches.pop_back();
                  if (!inheritedParentBranches.empty())
                     if (&(*inheritedParentBranches.back())->getSThenBranch() == branchToComplete.second) {
                        branchToComplete = std::make_pair(
                           &(*inheritedParentBranches.back())->getSElseValue(),
                           &(*inheritedParentBranches.back())->getSElseBranch());
                  }
               } while (!branchToComplete.first && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.insertAtEnd(mergeBranchIndex);
            branchToComplete.second->reset(new FldlibBase::TFloatingWithBranches<FloatingType>(
                  mergeBranchIndex, synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>(),
                  synthesizedValue,
                  std::shared_ptr<FldlibBase::TFloatingWithBranches<FloatingType>>()));
            inheritedParentBranches.push_back(branchToComplete.second);
            branchToComplete = std::make_pair(
               &(*inheritedParentBranches.back())->getSThenValue(),
               &(*inheritedParentBranches.back())->getSThenBranch());
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
      inherited::conditionalValue = result;
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::writeRealSynchronizationToMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   if (!inherited::conditionalValue.get()) {
      codeArray.insertAtEnd(0);
      inherited::value.writeRealSynchronizationToMemory(equationArray, codeArray);
      return;
   };
      
   std::vector<std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>*> inheritedParentBranches;
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   int treeRepresentation = 1;
   int index = 0;
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         treeRepresentation |= (1 << ++index);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
   codeArray.insertAtEnd(treeRepresentation);
   inheritedParentBranches.push_back(&const_cast<thisType*>(this)->conditionalValue);
   while (!inheritedParentBranches.empty()) {
      if (*inheritedParentBranches.back()) {
         codeArray.insertAtEnd((*inheritedParentBranches.back())->getMergeBranchIndex());
         if (!(*inheritedParentBranches.back())->getSThenBranch())
            (*inheritedParentBranches.back())->getSThenValue().writeRealSynchronizationToMemory(
                  equationArray, codeArray);
         inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSThenBranch());
      }
      else {
         std::shared_ptr<FldlibBase::TValueWithBranches<FloatingType>>* last;
         do {
            last = inheritedParentBranches.back();
            inheritedParentBranches.pop_back();
            if (!inheritedParentBranches.empty()) {
               ++index;
               if (&(*inheritedParentBranches.back())->getSThenBranch() == last) {
                  if (!(*inheritedParentBranches.back())->getSElseBranch())
                     (*inheritedParentBranches.back())->getSElseValue().writeRealSynchronizationToMemory(
                           equationArray, codeArray);
                  inheritedParentBranches.push_back(&(*inheritedParentBranches.back())->getSElseBranch());
                  break;
               }
            }
         } while (!inheritedParentBranches.empty());
      }
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::moveImplementationInMemory(
      DAffine::BasePathExplorer::AbstractImplementationArray& implementationArray,
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      inherited::value.moveImplementationInMemory(implementationArray, equationArray, codeArray);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<bool> inheritedParentBranches;
      FloatingType synthesizedValue;
      inheritedParentBranches.push_back(false);

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.moveImplementationInMemory(implementationArray, equationArray, codeArray);
            if (!inheritedParentBranches.back())
               inheritedParentBranches.back() = true;
            else {
               bool doesUp;
               do {
                  inheritedParentBranches.pop_back();
                  doesUp = (!inheritedParentBranches.empty()) ? inheritedParentBranches.back() : false;
               } while (doesUp && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(mergeBranchIndex);
            inheritedParentBranches.push_back(false);
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
   }
}

template <typename DoubleType> requires std::floating_point<DoubleType>
void
TFldlibFloatingBranchOption<TFldlibZonotopeOption<DoubleType>>::moveRealInMemory(
      DAffine::BasePathExplorer::AbstractEquationArray& equationArray, COL::TVector<int>& codeArray) const {
   typedef TFldlibZonotopeOption<DoubleType> FloatingType;
   int treeRepresentation = codeArray.first();
   codeArray.removeAt(0);
   codeArray.insertAtEnd(treeRepresentation);
   if (!treeRepresentation) {
      inherited::value.moveRealInMemory(equationArray, codeArray);
   }
   else {
      --treeRepresentation;
      int mergeBranchIndex = codeArray.first();
      codeArray.insertAtEnd(mergeBranchIndex);
      std::vector<bool> inheritedParentBranches;
      FloatingType synthesizedValue;
      inheritedParentBranches.push_back(false);

      // inheritedParentBranches, branchToComplete
      while (!inheritedParentBranches.empty()) {
         if (!(treeRepresentation & 0x1)) {
            synthesizedValue.moveRealInMemory(equationArray, codeArray);
            if (!inheritedParentBranches.back())
               inheritedParentBranches.back() = true;
            else {
               bool doesUp;
               do {
                  inheritedParentBranches.pop_back();
                  doesUp = (!inheritedParentBranches.empty()) ? inheritedParentBranches.back() : false;
               } while (doesUp && !inheritedParentBranches.empty());
            }
         }
         else {
            int mergeBranchIndex = codeArray.first();
            codeArray.removeAt(0);
            codeArray.insertAtEnd(mergeBranchIndex);
            inheritedParentBranches.push_back(false);
         }
         treeRepresentation >>= 1;
      }
      AssumeCondition(treeRepresentation == 0)
   }
}

template<typename T>
inline bool
TFLDLibVectorBranchOption<T>::forward_iterator::operator==(
      const forward_iterator& source) const
{  AssumeCondition(&vContainer == &source.vContainer);
   return uIndex == source.uIndex;
}

template<typename T>
inline bool
TFLDLibVectorBranchOption<T>::forward_iterator::operator!=(
      const forward_iterator& source) const
{  AssumeCondition(&vContainer == &source.vContainer);
   return uIndex != source.uIndex;
}

template<typename T>
inline void
TFLDLibVectorBranchOption<T>::erase(forward_iterator& iterator) {
   assert(&iterator.getContainer() == this);
   forward_iterator next_iterator(iterator);
   TFldlibIntegerBranchOption<int> previousIndex = next_iterator.getIndex();
   ++next_iterator;

   while (next_iterator.getIndex() != ibSizes) {
      ElementProperty(*this, previousIndex)
            = static_cast<const thisType&>(*this)[next_iterator.getIndex()];
      previousIndex = next_iterator.getIndex();
      ++next_iterator;
   }
   --ibSizes;
}

template<typename T>
inline void
TFLDLibVectorBranchOption<T>::erase(forward_iterator&& iterator) {
   assert(&iterator.getContainer() == this);
   forward_iterator next_iterator(iterator);
   TFldlibIntegerBranchOption<int> previousIndex = next_iterator.getIndex();
   ++next_iterator;

   while (next_iterator.getIndex() != ibSizes) {
      ElementProperty(*this, previousIndex)
            = static_cast<const thisType&>(*this)[next_iterator.getIndex()];
      previousIndex = next_iterator.getIndex();
      ++next_iterator;
   }
   --ibSizes;
}

} // end of namespace NumericalDomains
